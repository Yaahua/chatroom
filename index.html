<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å“ˆå‰ç±³å¾·çš„èŠå¤©å®¤</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.esm.js" type="module"></script>
    <style>
        :root{
            --bg:#f5f5f7;
            --bg-secondary:rgba(255,255,255,0.85);
            --surface:rgba(255,255,255,0.7);
            --text:#1d1d1f;
            --text-secondary:#6e6e73;
            --accent:#00c8aa;
            --accent-hover:#00b89c;
            --error:#ff3b30;
            --warning:#ff9500;
            --info:#007aff;
            --glass-border:rgba(255,255,255,0.4);
            --shadow:rgba(0,0,0,0.08);
            --input-bg:rgba(0,0,0,0.04);
            --code-bg:rgba(0,200,170,0.08);
            --system-bg:rgba(0,0,0,0.03);
            --hover-bg:rgba(0,0,0,0.05);
            --voice-bg:rgba(0,200,170,0.12);
        }
        [data-theme="dark"]{
            --bg:#0a0a0a;
            --bg-secondary:rgba(28,28,30,0.9);
            --surface:rgba(30,30,30,0.8);
            --text:#f5f5f7;
            --text-secondary:#8e8e93;
            --accent:#00d084;
            --accent-hover:#00b871;
            --error:#ff453a;
            --warning:#ff9f0a;
            --info:#0a84ff;
            --glass-border:rgba(255,255,255,0.1);
            --shadow:rgba(0,0,0,0.4);
            --input-bg:rgba(255,255,255,0.08);
            --code-bg:rgba(0,208,132,0.1);
            --system-bg:rgba(255,255,255,0.05);
            --hover-bg:rgba(255,255,255,0.08);
            --voice-bg:rgba(0,208,132,0.15);
        }
        
        *{margin:0;padding:0;box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,sans-serif;-webkit-tap-highlight-color:transparent;transition:background-color .3s ease,color .3s ease}
        body{background:var(--bg);color:var(--text);min-height:100dvh;overflow-x:hidden;position:relative;line-height:1.5;user-select:none}
        .hidden{display:none!important}
        
        .glass{
            background:var(--bg-secondary);
            backdrop-filter:blur(20px) saturate(180%);
            -webkit-backdrop-filter:blur(20px) saturate(180%);
            border:1px solid var(--glass-border);
            box-shadow:0 8px 32px 0 var(--shadow);
        }
        .glass-strong{
            background:var(--bg-secondary);
            backdrop-filter:blur(30px) saturate(200%);
            -webkit-backdrop-filter:blur(30px) saturate(200%);
            border:1px solid var(--glass-border);
        }
        
        /* ===== Setup é¡µé¢ ===== */
        #userSetup{position:fixed;inset:0;background:var(--bg);backdrop-filter:blur(10px);z-index:1000;display:flex;align-items:center;justify-content:center;padding:20px}
        #setup{min-height:100dvh;display:flex;align-items:center;justify-content:center;padding:20px}
        .card{padding:40px;border-radius:24px;max-width:460px;width:100%;position:relative;overflow:hidden}
        .user-avatar{width:72px;height:72px;border-radius:50%;background:linear-gradient(135deg,var(--accent),#00a8ff);display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:600;color:white;margin:0 auto 20px;box-shadow:0 4px 20px rgba(0,200,170,.3);border:3px solid var(--bg)}
        h1{font-size:28px;font-weight:700;margin-bottom:12px;background:linear-gradient(135deg,var(--text) 0%,var(--text-secondary) 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-align:center;letter-spacing:-.5px}
        .info{font-size:13px;color:var(--text-secondary);margin-bottom:28px;line-height:1.6;text-align:center;font-weight:400}
        
        button{
            width:100%;
            padding:16px;
            margin:8px 0;
            background:var(--accent);
            border:none;
            border-radius:14px;
            color:white;
            font-weight:600;
            cursor:pointer;
            font-size:15px;
            touch-action:manipulation;
            transition:all .3s cubic-bezier(.4,0,.2,1);
            box-shadow:0 2px 12px rgba(0,200,170,.25);
        }
        button:hover{transform:translateY(-1px);box-shadow:0 4px 20px rgba(0,200,170,.35);background:var(--accent-hover)}
        button:disabled{opacity:.4;cursor:not-allowed;transform:none;box-shadow:none}
        button.secondary{background:var(--hover-bg);color:var(--text);box-shadow:none}
        button.secondary:hover{background:var(--hover-bg);box-shadow:0 2px 12px var(--shadow)}
        button.danger{background:var(--error);box-shadow:0 2px 12px rgba(255,59,48,.25)}
        
        input[type="text"].setup-input{
            width:100%;
            padding:16px;
            background:var(--input-bg);
            border:1px solid var(--glass-border);
            border-radius:16px;
            color:var(--text);
            font-size:16px;
            text-align:center;
            letter-spacing:2px;
            margin:16px 0;
            outline:none;
            transition:all .3s;
            font-family:"SF Mono",monospace;
        }
        input[type="text"].setup-input:focus{border-color:var(--accent);background:var(--bg-secondary);box-shadow:0 0 0 4px rgba(0,200,170,.1)}
        
        /* ===== èŠå¤©ç•Œé¢ ===== */
        #chat{height:100dvh;overflow:hidden;display:flex;flex-direction:column;max-width:900px;margin:0 auto;position:relative;background:var(--bg)}
        
        /* Header - ä¿®å¤æ‹¥æŒ¤ */
        #header{
            display:flex;
            justify-content:space-between;
            align-items:center;
            padding:12px 16px;
            margin:12px 12px 8px;
            border-radius:20px;
            flex-shrink:0;
            z-index:10;
            gap:10px;
        }
        #roomInfo{
            display:flex;
            align-items:center;
            gap:12px;
            flex:1;
            min-width:0;
        }
        #roomTitle{
            font-size:17px;
            font-weight:700;
            color:var(--text);
            letter-spacing:1px;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
            cursor:pointer;
            padding:4px 8px;
            margin:-4px;
            border-radius:8px;
            transition:background .2s;
            max-width:120px;
        }
        #roomTitle:hover{background:var(--hover-bg)}
        #connectionStatus{
            font-size:11px;
            color:var(--text-secondary);
            display:flex;
            align-items:center;
            gap:6px;
            white-space:nowrap;
        }
        .conn-status{width:8px;height:8px;border-radius:50%;display:inline-block}
        .conn-status.connected{background:var(--accent);box-shadow:0 0 8px var(--accent)}
        .conn-status.connecting{background:var(--warning);animation:pulse 2s infinite}
        
        @keyframes pulse{0%,100%{opacity:1;transform:scale(1)}50%{opacity:.5;transform:scale(.9)}}
        
        #onlineCount{
            background:var(--code-bg);
            color:var(--accent);
            padding:6px 12px;
            border-radius:20px;
            font-size:12px;
            font-weight:600;
            border:1px solid var(--glass-border);
            white-space:nowrap;
            flex-shrink:0;
        }
        
        .theme-toggle{
            width:36px!important;
            height:36px!important;
            padding:0!important;
            margin:0!important;
            border-radius:50%!important;
            background:var(--hover-bg)!important;
            border:1px solid var(--glass-border)!important;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            flex-shrink:0;
            box-shadow:none!important;
        }
        .theme-toggle svg{width:20px;height:20px;color:var(--text-secondary)}
        
        #header > button.danger{
            width:auto!important;
            padding:8px 14px!important;
            font-size:12px!important;
            margin:0!important;
            border-radius:12px!important;
            flex-shrink:0;
        }
        
        /* æ¶ˆæ¯åŒºåŸŸ */
        #messages{
            flex:1;
            overflow-y:auto;
            padding:20px;
            padding-bottom:100px;
            display:flex;
            flex-direction:column;
            gap:16px;
            scroll-behavior:smooth;
        }
        .msg{
            max-width:85%;
            animation:messageIn .3s cubic-bezier(.4,0,.2,1);
            position:relative;
        }
        @keyframes messageIn{
            from{opacity:0;transform:translateY(20px) scale(.95)}
            to{opacity:1;transform:translateY(0) scale(1)}
        }
        .msg-header{
            display:flex;
            align-items:center;
            gap:8px;
            margin-bottom:6px;
            font-size:12px;
            color:var(--text-secondary);
            padding:0 4px;
        }
        .msg-author{font-weight:600;color:var(--text)}
        .msg-time{font-size:11px;opacity:.7;font-family:"SF Mono",monospace}
        .msg-content{
            padding:12px 16px;
            border-radius:20px;
            word-break:break-word;
            line-height:1.5;
            font-size:15px;
            color:var(--text);
            background:var(--bg-secondary);
            border:1px solid var(--glass-border);
            box-shadow:0 2px 12px var(--shadow);
        }
        .msg.self{margin-left:auto}
        .msg.self .msg-content{
            background:var(--accent);
            color:white;
            border:none;
            box-shadow:0 4px 16px rgba(0,200,170,.25);
        }
        .msg.system{align-self:center;max-width:90%}
        .msg.system .msg-content{
            background:var(--system-bg);
            border:1px solid var(--glass-border);
            color:var(--text-secondary);
            font-size:13px;
            padding:8px 16px;
            border-radius:16px;
        }
        
        /* å›¾ç‰‡æ¶ˆæ¯ */
        .msg-image{
            max-width:240px;
            max-height:240px;
            border-radius:16px;
            cursor:pointer;
            display:block;
            object-fit:cover;
            box-shadow:0 4px 16px rgba(0,0,0,.1);
        }
        .msg.self .msg-image{box-shadow:0 4px 16px rgba(0,0,0,.2)}
        
        /* æ–‡ä»¶æ¶ˆæ¯ */
        .msg-file{
            display:flex;
            align-items:center;
            gap:12px;
            padding:12px 16px;
            max-width:280px;
            cursor:pointer;
            background:var(--bg-secondary);
            border-radius:16px;
            border:1px solid var(--glass-border);
        }
        .msg.self .msg-file{background:rgba(255,255,255,0.2);border-color:rgba(255,255,255,0.3)}
        .file-icon{
            width:48px;
            height:48px;
            border-radius:12px;
            background:linear-gradient(135deg,var(--info),#5856d6);
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:24px;
            flex-shrink:0;
        }
        .msg.self .file-icon{background:rgba(255,255,255,0.3)}
        .file-info{flex:1;min-width:0}
        .file-name{font-weight:600;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:4px}
        .file-size{font-size:12px;opacity:.7}
        
        /* è¯­éŸ³æ¶ˆæ¯ */
        .msg-voice{
            display:flex;
            align-items:center;
            gap:12px;
            padding:10px 14px;
            min-width:120px;
            max-width:220px;
            cursor:pointer;
            background:var(--voice-bg);
            border-radius:20px;
        }
        .msg.self .msg-voice{background:rgba(255,255,255,0.3);flex-direction:row-reverse}
        .voice-icon{width:32px;height:32px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;color:white;font-size:14px;flex-shrink:0}
        .msg.self .voice-icon{background:rgba(255,255,255,0.9);color:var(--accent)}
        .voice-duration{font-weight:600;font-size:14px}
        
        /* ===== è¾“å…¥æ¡†åŒºåŸŸ - å…³é”®ä¿®å¤ ===== */
        #input{
            position:fixed;
            bottom:0;
            left:50%;
            transform:translateX(-50%);
            width:100%;
            max-width:900px;
            padding:12px 16px;
            padding-bottom:calc(16px + env(safe-area-inset-bottom,20px));
            border-top:1px solid var(--glass-border);
            display:flex;
            align-items:center;
            gap:8px;
            z-index:999;
            background:var(--bg-secondary);
            backdrop-filter:blur(20px);
        }
        
        /* å…³é”®ä¿®å¤ï¼šä¸­é—´å®¹å™¨å…è®¸æ”¶ç¼© */
        .input-center{
            flex:1;
            display:flex;
            align-items:center;
            gap:8px;
            min-width:0; /* å…è®¸æ”¶ç¼© */
            position:relative;
        }
        
        #inputWrapper{
            flex:1;
            display:flex;
            align-items:center;
            background:var(--input-bg);
            border:1px solid var(--glass-border);
            border-radius:24px;
            padding:6px 12px;
            min-width:0; /* å…³é”®ï¼šé˜²æ­¢æ’‘å¼€ */
            transition:all .3s;
        }
        #inputWrapper:focus-within{
            background:var(--bg-secondary);
            border-color:var(--accent);
            box-shadow:0 0 0 4px rgba(0,200,170,.1);
        }
        
        #msgInput{
            flex:1;
            padding:8px 4px;
            background:transparent;
            border:none;
            color:var(--text);
            font-size:16px;
            outline:none;
            min-width:0; /* å…³é”® */
        }
        #msgInput::placeholder{color:var(--text-secondary);opacity:.6}
        #msgInput:disabled{opacity:.5;cursor:not-allowed}
        
        /* æŒ‰é’®å›ºå®šå°ºå¯¸ï¼Œç¦æ­¢å‹ç¼© */
        .input-btn{
            width:40px!important;
            height:40px!important;
            padding:0!important;
            margin:0!important;
            border-radius:50%!important;
            background:var(--bg-secondary)!important;
            border:1px solid var(--glass-border)!important;
            color:var(--text)!important;
            font-size:20px!important;
            display:flex!important;
            align-items:center!important;
            justify-content:center!important;
            flex-shrink:0!important; /* å…³é”®ä¿®å¤ */
            box-shadow:0 2px 8px var(--shadow)!important;
        }
        .input-btn:active{transform:scale(.95)}
        
        .send-btn{
            width:auto!important;
            padding:10px 20px!important;
            border-radius:20px!important;
            white-space:nowrap!important;
            font-weight:600!important;
            flex-shrink:0!important; /* å…³é”®ä¿®å¤ */
            margin:0!important;
        }
        
        .voice-record-btn{
            flex:1;
            height:44px;
            border-radius:22px;
            background:var(--input-bg);
            border:1px solid var(--glass-border);
            color:var(--text);
            font-weight:600;
            font-size:15px;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            user-select:none;
            touch-action:none;
        }
        .voice-record-btn.recording{
            background:var(--voice-bg);
            border-color:var(--accent);
            color:var(--accent);
            animation:recordingPulse 1.5s infinite;
        }
        @keyframes recordingPulse{
            0%,100%{box-shadow:0 0 0 0 rgba(0,200,170,.4)}
            50%{box-shadow:0 0 0 10px rgba(0,200,170,0)}
        }
        
        /* ===== â•å·èœå•ï¼ˆç±»ä¼¼å¾®ä¿¡ï¼‰ ===== */
        #plusMenu{
            position:fixed;
            inset:0;
            z-index:2000;
            opacity:0;
            transition:opacity .3s;
            pointer-events:none;
        }
        #plusMenu.show{
            opacity:1;
            pointer-events:auto;
        }
        #plusMenu .menu-mask{
            position:absolute;
            inset:0;
            background:rgba(0,0,0,0.4);
            backdrop-filter:blur(2px);
        }
        #plusMenu .menu-content{
            position:absolute;
            bottom:0;
            left:0;
            right:0;
            background:var(--bg-secondary);
            backdrop-filter:blur(30px);
            border-top:1px solid var(--glass-border);
            border-radius:24px 24px 0 0;
            padding:24px 20px calc(24px + env(safe-area-inset-bottom));
            transform:translateY(100%);
            transition:transform .3s cubic-bezier(.4,0,.2,1);
        }
        #plusMenu.show .menu-content{transform:translateY(0)}
        
        .menu-grid{
            display:grid;
            grid-template-columns:repeat(4,1fr);
            gap:16px;
            margin-bottom:24px;
        }
        .menu-item{
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:8px;
            background:transparent;
            border:none;
            padding:12px;
            margin:0;
            box-shadow:none;
            cursor:pointer;
        }
        .menu-item:active{transform:scale(.95)}
        .menu-icon{
            width:64px;
            height:64px;
            border-radius:20px;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:28px;
            box-shadow:0 4px 16px rgba(0,0,0,0.1);
            transition:transform .2s;
        }
        .menu-item:hover .menu-icon{transform:translateY(-2px)}
        .menu-icon.purple{background:linear-gradient(135deg,#af52de,#5856d6)}
        .menu-icon.blue{background:linear-gradient(135deg,#007aff,#00c8aa)}
        .menu-icon.orange{background:linear-gradient(135deg,#ff9500,#ff3b30)}
        .menu-icon.green{background:linear-gradient(135deg,#34c759,#00c8aa)}
        .menu-label{font-size:13px;color:var(--text);font-weight:500}
        
        .menu-cancel{
            width:100%;
            padding:16px;
            background:var(--hover-bg);
            color:var(--text);
            border-radius:12px;
            font-weight:600;
            margin:0;
        }
        
        /* å½•éŸ³è¦†ç›–å±‚ */
        #recordOverlay{
            position:fixed;
            inset:0;
            background:rgba(0,0,0,.6);
            backdrop-filter:blur(10px);
            z-index:1000;
            display:none;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            gap:40px;
            opacity:0;
            transition:opacity .3s;
        }
        #recordOverlay.show{display:flex;opacity:1}
        .record-wave-container{
            width:180px;
            height:180px;
            border-radius:50%;
            background:var(--bg-secondary);
            display:flex;
            align-items:center;
            justify-content:center;
            position:relative;
        }
        .record-timer{font-size:48px;font-weight:700;color:var(--text);font-family:"SF Mono",monospace}
        
        /* å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† */
        #imageModal{
            position:fixed;
            inset:0;
            background:rgba(0,0,0,.95);
            backdrop-filter:blur(20px);
            z-index:3000;
            display:none;
            align-items:center;
            justify-content:center;
            padding:20px;
        }
        #imageModal.show{display:flex}
        #imageModal img{max-width:100%;max-height:90vh;object-fit:contain;border-radius:12px}
        .close-modal{
            position:absolute;
            top:24px;
            right:24px;
            width:44px!important;
            height:44px!important;
            border-radius:50%!important;
            background:var(--bg-secondary)!important;
            border:1px solid var(--glass-border)!important;
            color:var(--text)!important;
            font-size:24px!important;
            display:flex!important;
            align-items:center!important;
            justify-content:center!important;
            margin:0!important;
            padding:0!important;
        }
        
        /* Toast */
        .toast{
            position:fixed;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%) scale(.9);
            background:var(--bg-secondary);
            backdrop-filter:blur(20px);
            color:var(--text);
            padding:16px 28px;
            border-radius:16px;
            z-index:4000;
            font-size:14px;
            font-weight:500;
            opacity:0;
            transition:all .3s;
            pointer-events:none;
            box-shadow:0 20px 60px var(--shadow);
            border:1px solid var(--glass-border);
        }
        .toast.show{opacity:1;transform:translate(-50%,-50%) scale(1)}
        
        /* è¿›åº¦æ¡ï¼ˆç”¨äºæ–‡ä»¶ä¸Šä¼ ï¼‰ */
        .progress-bar{
            height:4px;
            background:var(--hover-bg);
            border-radius:2px;
            margin-top:8px;
            overflow:hidden;
        }
        .progress-fill{
            height:100%;
            background:var(--accent);
            border-radius:2px;
            transition:width .3s;
            width:0%;
        }
        
        @media (max-width:600px){
            .card{padding:28px 20px}
            h1{font-size:24px}
            .msg{max-width:90%}
            #header{margin:8px;padding:12px}
            .menu-grid{grid-template-columns:repeat(4,1fr)}
            .menu-icon{width:56px;height:56px;font-size:24px}
        }
    </style>
</head>
<body>
    <div id="toast" class="toast"></div>

    <!-- å½•éŸ³è¦†ç›–å±‚ -->
    <div id="recordOverlay" onclick="window.chatApp?.cancelRecord()">
        <div class="record-timer" id="recordTimer">00:00</div>
        <div class="record-wave-container">
            <div style="font-size:64px">ğŸ™ï¸</div>
        </div>
        <div style="color:var(--text-secondary);font-size:14px">æ¾å¼€å‘é€ï¼Œä¸Šæ»‘å–æ¶ˆ</div>
    </div>

    <!-- å›¾ç‰‡é¢„è§ˆ -->
    <div id="imageModal" onclick="window.chatApp?.closeImageModal()">
        <button class="close-modal" onclick="event.stopPropagation(); window.chatApp?.closeImageModal()">Ã—</button>
        <img id="modalImage" src="" alt="é¢„è§ˆ">
    </div>

    <!-- â•å·èœå•ï¼ˆç±»ä¼¼å¾®ä¿¡ï¼‰ -->
    <div id="plusMenu" class="hidden">
        <div class="menu-mask" onclick="window.chatApp?.closePlusMenu()"></div>
        <div class="menu-content glass-strong">
            <div class="menu-grid">
                <button class="menu-item" onclick="window.chatApp?.selectImageSource('camera')">
                    <div class="menu-icon purple">ğŸ“·</div>
                    <span class="menu-label">æ‹æ‘„</span>
                </button>
                <button class="menu-item" onclick="window.chatApp?.selectImageSource('gallery')">
                    <div class="menu-icon blue">ğŸ–¼ï¸</div>
                    <span class="menu-label">ç›¸å†Œ</span>
                </button>
                <button class="menu-item" onclick="window.chatApp?.selectFile()">
                    <div class="menu-icon orange">ğŸ“„</div>
                    <span class="menu-label">æ–‡ä»¶</span>
                </button>
                <button class="menu-item" onclick="window.chatApp?.closePlusMenu()">
                    <div class="menu-icon green">âŒ</div>
                    <span class="menu-label">å…³é—­</span>
                </button>
            </div>
            <button class="menu-cancel" onclick="window.chatApp?.closePlusMenu()">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="imageInput" class="hidden" accept="image/*" onchange="window.chatApp?.handleImageSelect(event)">
    <input type="file" id="fileInput" class="hidden" multiple onchange="window.chatApp?.handleFileSelect(event)">

    <!-- ç”¨æˆ·åè®¾ç½® -->
    <div id="userSetup">
        <div class="card glass-strong" style="max-width:400px">
            <div class="user-avatar" id="avatarPreview">?</div>
            <h2 style="text-align:center;margin-bottom:8px;font-weight:700;color:var(--text)">è®¾ç½®èº«ä»½</h2>
            <input type="text" id="usernameInput" placeholder="æ˜µç§° (2-12å­—)" maxlength="12" class="setup-input" style="text-transform:none;letter-spacing:0;font-family:inherit">
            <div style="font-size:12px;color:var(--text-secondary);text-align:center;margin-bottom:20px;font-weight:500">
                è¿›å…¥åæ— æ³•ä¿®æ”¹
            </div>
            <button onclick="window.chatApp?.setUsername()" id="confirmUserBtn" style="border-radius:16px">è¿›å…¥</button>
        </div>
    </div>

    <!-- æˆ¿é—´é€‰æ‹© -->
    <div id="setup">
        <div class="card glass">
            <h1>E2E åŠ å¯†èŠå¤©å®¤</h1>
            <div class="info">
                ç«¯åˆ°ç«¯åŠ å¯† Â· æ¶ˆæ¯ç§’è¾¾<br>
                æ”¯æŒæ–‡å­—ã€å›¾ç‰‡ã€è¯­éŸ³ã€æ–‡ä»¶
            </div>
            
            <div id="userInfo" class="glass" style="display:flex;align-items:center;gap:12px;margin-bottom:24px;padding:16px;border-radius:16px;background:var(--surface)">
                <div class="user-avatar" style="width:44px;height:44px;font-size:18px;margin:0" id="displayAvatar">?</div>
                <div style="flex:1">
                    <div style="font-size:11px;color:var(--text-secondary);font-weight:600;text-transform:uppercase;letter-spacing:0.5px">å½“å‰èº«ä»½</div>
                    <div style="font-weight:700;color:var(--text);font-size:16px" id="displayUsername">æœªè®¾ç½®</div>
                </div>
            </div>
            
            <button onclick="window.chatApp?.createRoom()" id="createBtn" style="border-radius:16px">åˆ›å»ºæˆ¿é—´</button>
            <button onclick="window.chatApp?.showJoin()" id="joinBtn" class="secondary" style="border-radius:16px">åŠ å…¥æˆ¿é—´</button>
            
            <div id="createPanel" class="hidden" style="margin-top:20px">
                <div class="loading" id="createLoading">
                    <div class="spinner" style="width:18px;height:18px;border:2px solid var(--warning);border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle;margin-right:8px"></div>
                    <span>ç”ŸæˆåŠ å¯†å¯†é’¥...</span>
                </div>
                <div class="code-display hidden" id="roomCodeDisplay" style="font-size:32px;font-weight:700;color:var(--accent);letter-spacing:8px;text-align:center;padding:20px;background:var(--code-bg);border-radius:16px;margin:20px 0;border:2px dashed var(--accent);font-family:monospace"></div>
            </div>
            
            <div id="joinPanel" class="hidden" style="margin-top:20px">
                <label style="font-size:12px;color:var(--text-secondary);font-weight:600;margin-bottom:8px;display:block">æˆ¿é—´ä»£ç </label>
                <input type="text" id="joinCode" placeholder="ABC123" maxlength="6" autocomplete="off" autocapitalize="characters" class="setup-input" style="border-radius:16px">
                <button onclick="window.chatApp?.joinRoom()" id="connectBtn" style="border-radius:16px;margin-top:8px">åŠ å…¥</button>
                <div id="joinLoading" class="loading hidden" style="margin-top:12px;color:var(--warning)">
                    <div class="spinner" style="width:18px;height:18px;border:2px solid currentColor;border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle;margin-right:8px"></div>
                    <span>æ­£åœ¨è¿æ¥...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- èŠå¤©ç•Œé¢ -->
    <div id="chat" class="hidden">
        <div id="header" class="glass-strong">
            <div id="roomInfo">
                <div style="min-width:0">
                    <div id="roomTitle" onclick="window.chatApp?.copyRoomCode()" title="ç‚¹å‡»å¤åˆ¶">æˆ¿é—´</div>
                    <div id="connectionStatus">
                        <span class="conn-status connecting"></span>
                        <span id="connText">è¿æ¥ä¸­</span>
                    </div>
                </div>
                <div id="onlineCount">1äººåœ¨çº¿</div>
            </div>
            
            <button class="theme-toggle" onclick="window.chatApp?.toggleTheme()" title="åˆ‡æ¢ä¸»é¢˜">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5" fill="currentColor" fill-opacity="0.2"></circle>
                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"></path>
                </svg>
            </button>
            
            <button onclick="window.chatApp?.confirmLeave()" class="danger">é€€å‡º</button>
        </div>
        
        <div id="messages"></div>
        
        <!-- è¾“å…¥åŒºåŸŸ - é‡æ„ä¿®å¤ -->
        <div id="input" class="glass-strong">
            <!-- â•å·æŒ‰é’® -->
            <button class="input-btn" onclick="window.chatApp?.openPlusMenu()" title="æ›´å¤š" style="font-size:24px;font-weight:300">âŠ•</button>
            
            <!-- ä¸­é—´åŒºåŸŸï¼ˆå¯æ”¶ç¼©ï¼‰ -->
            <div class="input-center" id="textInputWrapper">
                <div id="inputWrapper">
                    <input type="text" id="msgInput" placeholder="å‘é€åŠ å¯†æ¶ˆæ¯..." maxlength="1000" autocomplete="off" enterkeyhint="send" onkeypress="if(event.key==='Enter')window.chatApp?.send()">
                </div>
                
                <!-- è¯­éŸ³æŒ‰é’®ï¼ˆåˆ‡æ¢æ¨¡å¼ï¼‰ -->
                <button class="input-btn" onclick="window.chatApp?.toggleInputMode()" title="åˆ‡æ¢è¯­éŸ³" id="modeToggleBtn">ğŸ™ï¸</button>
            </div>
            
            <!-- è¯­éŸ³è¾“å…¥æ¨¡å¼ï¼ˆé»˜è®¤éšè—ï¼‰ -->
            <div class="input-center hidden" id="voiceInputWrapper">
                <button class="voice-record-btn" id="recordBtn" 
                    onmousedown="window.chatApp?.startRecord(event)" 
                    ontouchstart="window.chatApp?.startRecord(event)"
                    onmouseup="window.chatApp?.stopRecord(event)"
                    ontouchend="window.chatApp?.stopRecord(event)"
                    onmousemove="window.chatApp?.handleRecordMove(event)"
                    ontouchmove="window.chatApp?.handleRecordMove(event)">
                    æŒ‰ä½è¯´è¯
                </button>
            </div>
            
            <!-- å‘é€æŒ‰é’®ï¼ˆå›ºå®šå°ºå¯¸ï¼Œç¦æ­¢å‹ç¼©ï¼‰ -->
            <button onclick="window.chatApp?.send()" class="send-btn" id="sendBtn">å‘é€</button>
        </div>
    </div>

    <script type="module">
        import mqtt from 'https://unpkg.com/mqtt/dist/mqtt.esm.js';

        // ==================== é…ç½® ====================
        const CONFIG = {
            MQTT_URL: 'wss://5e07b91bbaac4825af958ca9084c5542.s1.eu.hivemq.cloud:8884/mqtt',
            MQTT_USERNAME: 'hajimi',
            MQTT_PASSWORD: '258758Szh',
            CHUNK_SIZE: 80 * 1024, // 80KB åˆ†ç‰‡
            MAX_FILE_SIZE: 20 * 1024 * 1024, // 20MB
            MAX_VOICE_DURATION: 60 // 60ç§’
        };

        // ==================== å·¥å…·ç±» ====================
        class Utils {
            static generateUUID() {
                return crypto.randomUUID ? crypto.randomUUID() : 
                    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                        const r = Math.random() * 16 | 0;
                        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                    });
            }
            static getAvatarColor(name) {
                const colors = ['#007aff', '#34c759', '#ff9500', '#ff3b30', '#af52de', '#5856d6', '#ff2d55', '#5ac8fa'];
                let hash = 0;
                for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash);
                return colors[Math.abs(hash) % colors.length];
            }
            static generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                const array = new Uint8Array(6);
                crypto.getRandomValues(array);
                return Array.from(array, x => chars[x % chars.length]).join('');
            }
            static formatTime(date) { 
                return new Date(date).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
            }
            static escapeHtml(text) { 
                const div = document.createElement('div'); 
                div.textContent = text; 
                return div.innerHTML; 
            }
            static formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            }
            static arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
                return window.btoa(binary);
            }
            static base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
                return bytes.buffer;
            }
        }

        // ==================== åŠ å¯†ç±» ====================
        class E2EEncryption {
            constructor() {
                this.keyPair = null;
                this.roomKey = null;
            }
            async generateKeyPair() {
                this.keyPair = await crypto.subtle.generateKey(
                    { name: "ECDH", namedCurve: "P-256" },
                    true, ["deriveKey"]
                );
                return this.keyPair;
            }
            async generateRoomKey() {
                this.roomKey = await crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true, ["encrypt", "decrypt"]
                );
                return this.roomKey;
            }
            async exportRoomKey() {
                if (!this.roomKey) return null;
                return await crypto.subtle.exportKey("raw", this.roomKey);
            }
            async importRoomKey(rawKey) {
                this.roomKey = await crypto.subtle.importKey(
                    "raw", rawKey,
                    { name: "AES-GCM" },
                    true, ["encrypt", "decrypt"]
                );
            }
            async deriveSharedSecret(peerPublicKeyJwk) {
                const peerKey = await crypto.subtle.importKey(
                    "jwk", peerPublicKeyJwk,
                    { name: "ECDH", namedCurve: "P-256" },
                    false, []
                );
                return await crypto.subtle.deriveKey(
                    { name: "ECDH", public: peerKey },
                    this.keyPair.privateKey,
                    { name: "AES-GCM", length: 256 },
                    false, ["encrypt", "decrypt"]
                );
            }
            async encryptGroupMessage(text) {
                if (!this.roomKey) throw new Error("ç­‰å¾…å¯†é’¥åŒæ­¥...");
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encoded = new TextEncoder().encode(text);
                const ciphertext = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    this.roomKey,
                    encoded
                );
                const combined = new Uint8Array(iv.length + ciphertext.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(ciphertext), iv.length);
                return Utils.arrayBufferToBase64(combined.buffer);
            }
            async decryptGroupMessage(base64) {
                if (!this.roomKey) return "[ç­‰å¾…å¯†é’¥...]";
                try {
                    const combined = Utils.base64ToArrayBuffer(base64);
                    const iv = combined.slice(0, 12);
                    const data = combined.slice(12);
                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: new Uint8Array(iv) },
                        this.roomKey,
                        data
                    );
                    return new TextDecoder().decode(decrypted);
                } catch (e) {
                    return "[è§£å¯†å¤±è´¥]";
                }
            }
            async exportPublicKey() {
                return crypto.subtle.exportKey("jwk", this.keyPair.publicKey);
            }
        }

        // ==================== è¯­éŸ³ç®¡ç†å™¨ ====================
        class VoiceManager {
            constructor(chatApp) {
                this.app = chatApp;
                this.recorder = null;
                this.audioChunks = [];
                this.recordStartTime = 0;
                this.recordTimer = null;
                this.isRecording = false;
                this.recordCancelZone = false;
            }
            
            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { sampleRate: 16000, channelCount: 1 } 
                    });
                    this.audioChunks = [];
                    this.recorder = new MediaRecorder(stream, { 
                        mimeType: MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 
                            'audio/webm;codecs=opus' : 'audio/webm' 
                    });
                    this.recorder.ondataavailable = (e) => { 
                        if (e.data.size > 0) this.audioChunks.push(e.data); 
                    };
                    this.recorder.onstop = () => { 
                        this.finalizeRecording(); 
                        stream.getTracks().forEach(track => track.stop()); 
                    };
                    this.recorder.start(100);
                    this.recordStartTime = Date.now();
                    this.startRecordTimer();
                    return true;
                } catch (err) { 
                    console.error('å½•éŸ³å¤±è´¥:', err); 
                    return false; 
                }
            }
            
            startRecordTimer() {
                const update = () => {
                    const elapsed = Math.floor((Date.now() - this.recordStartTime) / 1000);
                    if (elapsed >= CONFIG.MAX_VOICE_DURATION) {
                        this.stopRecording();
                        return;
                    }
                    const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const secs = (elapsed % 60).toString().padStart(2, '0');
                    const el = document.getElementById('recordTimer');
                    if (el) el.textContent = `${mins}:${secs}`;
                };
                update();
                this.recordTimer = setInterval(update, 1000);
            }
            
            stopRecording(canceled = false) {
                if (this.recordTimer) { clearInterval(this.recordTimer); this.recordTimer = null; }
                if (this.recorder && this.recorder.state !== 'inactive') { 
                    this.recorder.stop(); 
                    this.canceled = canceled; 
                }
                this.isRecording = false;
            }
            
            async finalizeRecording() {
                if (this.canceled || this.audioChunks.length === 0) return;
                const duration = Math.floor((Date.now() - this.recordStartTime) / 1000);
                if (duration < 1) { this.app.showToast('å½•éŸ³å¤ªçŸ­'); return; }
                
                const blob = new Blob(this.audioChunks, { type: 'audio/webm' });
                const voiceId = `voice_${this.app.user.id}_${Date.now()}`;
                
                // æœ¬åœ°æ˜¾ç¤º
                this.app.displayVoiceMessage({
                    voiceId, duration, blob, local: true,
                    userId: this.app.user.id, username: this.app.user.name,
                    avatarColor: this.app.user.color, timestamp: new Date().toISOString()
                }, true);
                
                // è½¬base64å¹¶é€šè¿‡MQTTå‘é€
                const reader = new FileReader();
                reader.onloadend = async () => {
                    const base64 = reader.result.split(',')[1];
                    await this.app.sendViaMQTT(base64, {
                        voiceId, fileType: 'voice', duration
                    });
                };
                reader.readAsDataURL(blob);
            }
        }

        // ==================== ä¸»åº”ç”¨ç±» ====================
        class ChatApplication {
            constructor() {
                this.user = { name: null, id: null, color: null };
                this.room = { code: null, isHost: false };
                this.mqtt = { client: null, connected: false };
                this.messages = { seq: 0, cache: new Set() };
                this.e2e = new E2EEncryption();
                this.voiceManager = new VoiceManager(this);
                this.theme = localStorage.getItem('theme') || 'light';
                this.inputMode = 'text';
                this.fileTransfers = new Map(); // æ¥æ”¶ä¸­çš„æ–‡ä»¶
                this.CHUNK_SIZE = CONFIG.CHUNK_SIZE;
                
                this.init();
            }

            async init() {
                document.documentElement.setAttribute('data-theme', this.theme);
                
                const savedName = sessionStorage.getItem('p2p_username');
                const savedId = sessionStorage.getItem('p2p_userid');
                if (savedName && savedId) {
                    this.user.name = savedName;
                    this.user.id = savedId;
                    this.user.color = Utils.getAvatarColor(savedName);
                    this.updateUserDisplay();
                }
                
                if ('ontouchstart' in window) document.body.classList.add('touch-device');
                this.setupEventListeners();
                await this.e2e.generateKeyPair();
            }

            setupEventListeners() {
                document.getElementById('usernameInput')?.addEventListener('input', (e) => {
                    const val = e.target.value.trim();
                    const avatar = document.getElementById('avatarPreview');
                    avatar.textContent = val ? val.charAt(0).toUpperCase() : '?';
                    if (val) avatar.style.background = Utils.getAvatarColor(val);
                });
                
                window.addEventListener('beforeunload', () => {
                    if (this.mqtt.client) {
                        this.publish('presence', { action: 'leave', username: this.user.name });
                        this.mqtt.client.end();
                    }
                });
            }

            // ==================== MQTT åˆ†ç‰‡ä¼ è¾“æ ¸å¿ƒ ====================
            async sendViaMQTT(dataBase64, meta, onProgress) {
                const totalSize = dataBase64.length;
                const totalChunks = Math.ceil(totalSize / this.CHUNK_SIZE);
                const transferId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // å‘é€å…ƒæ•°æ®
                this.publish('broadcast', {
                    type: 'file_meta',
                    transferId, totalChunks, meta,
                    sender: { id: this.user.id, name: this.user.name, color: this.user.color }
                });
                
                // é€ç‰‡å‘é€ï¼ˆå¸¦æµæ§ï¼‰
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * this.CHUNK_SIZE;
                    const chunk = dataBase64.slice(start, start + this.CHUNK_SIZE);
                    
                    this.publish('broadcast', {
                        type: 'file_chunk',
                        transferId, index: i, data: chunk,
                        isLast: i === totalChunks - 1
                    });
                    
                    if (onProgress) onProgress(Math.round((i + 1) / totalChunks * 100));
                    if (i < totalChunks - 1) await new Promise(r => setTimeout(r, 30));
                }
            }

            handleFileTransfer(data) {
                if (data.type === 'file_meta') {
                    this.fileTransfers.set(data.transferId, {
                        chunks: new Array(data.totalChunks).fill(null),
                        received: 0,
                        meta: data.meta,
                        sender: data.sender,
                        timeout: setTimeout(() => {
                            this.fileTransfers.delete(data.transferId);
                        }, 120000)
                    });
                    if (data.meta.fileType !== 'voice') {
                        this.showToast(`${data.sender.name} æ­£åœ¨å‘é€æ–‡ä»¶...`);
                    }
                } else if (data.type === 'file_chunk') {
                    const transfer = this.fileTransfers.get(data.transferId);
                    if (!transfer) return;
                    
                    transfer.chunks[data.index] = data.data;
                    transfer.received++;
                    
                    const isComplete = transfer.received === transfer.meta.totalChunks || data.isLast;
                    if (isComplete) {
                        clearTimeout(transfer.timeout);
                        const fullData = transfer.chunks.join('');
                        this.processCompleteFile(fullData, transfer.meta, transfer.sender);
                        this.fileTransfers.delete(data.transferId);
                    }
                }
            }

            processCompleteFile(dataBase64, meta, sender) {
                if (meta.fileType === 'image') {
                    this.displayMessage({
                        id: meta.id, userId: sender.id, username: sender.name,
                        avatarColor: sender.color,
                        content: `data:image/jpeg;base64,${dataBase64}`,
                        type: 'image', sizeHint: meta.sizeHint,
                        timestamp: new Date().toISOString()
                    }, false);
                } else if (meta.fileType === 'voice') {
                    const byteCharacters = atob(dataBase64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const blob = new Blob([new Uint8Array(byteNumbers)], { type: 'audio/webm' });
                    this.displayVoiceMessage({
                        voiceId: meta.voiceId, duration: meta.duration, blob,
                        userId: sender.id, username: sender.name,
                        avatarColor: sender.color, timestamp: new Date().toISOString()
                    }, false);
                } else if (meta.fileType === 'file') {
                    const blob = this.base64ToBlob(dataBase64, meta.mimeType);
                    const url = URL.createObjectURL(blob);
                    this.displayFileMessage({
                        id: meta.id, userId: sender.id, username: sender.name,
                        avatarColor: sender.color, fileName: meta.fileName,
                        fileSize: Utils.formatFileSize(meta.fileSize), blobUrl: url,
                        timestamp: new Date().toISOString()
                    }, false);
                }
            }

            base64ToBlob(base64, mimeType) {
                const byteCharacters = atob(base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                return new Blob([new Uint8Array(byteNumbers)], { type: mimeType || 'application/octet-stream' });
            }

            // ==================== ç”¨æˆ·ä¸æˆ¿é—´ç®¡ç† ====================
            setUsername() {
                const input = document.getElementById('usernameInput');
                const name = input.value.trim();
                if (!name || name.length < 2) return alert('è¯·è¾“å…¥è‡³å°‘2ä¸ªå­—ç¬¦');
                
                this.user.name = name;
                this.user.id = Utils.generateUUID();
                this.user.color = Utils.getAvatarColor(name);
                
                sessionStorage.setItem('p2p_username', this.user.name);
                sessionStorage.setItem('p2p_userid', this.user.id);
                sessionStorage.setItem('p2p_color', this.user.color);
                
                this.updateUserDisplay();
                document.getElementById('userSetup').classList.add('hidden');
            }

            updateUserDisplay() {
                document.getElementById('displayUsername').textContent = this.user.name;
                const avatar = document.getElementById('displayAvatar');
                avatar.textContent = this.user.name.charAt(0).toUpperCase();
                avatar.style.background = this.user.color;
                document.getElementById('avatarPreview').textContent = this.user.name.charAt(0).toUpperCase();
                document.getElementById('avatarPreview').style.background = this.user.color;
            }

            async createRoom() {
                if (!this.user.name) {
                    document.getElementById('userSetup').classList.remove('hidden');
                    return;
                }
                this.room.isHost = true;
                this.room.code = Utils.generateRoomCode();
                await this.e2e.generateRoomKey();
                
                document.getElementById('createBtn').classList.add('hidden');
                document.getElementById('joinBtn').classList.add('hidden');
                document.getElementById('createPanel').classList.remove('hidden');
                
                try {
                    await this.connectMQTT();
                    document.getElementById('createLoading').classList.add('hidden');
                    document.getElementById('roomCodeDisplay').classList.remove('hidden');
                    document.getElementById('roomCodeDisplay').textContent = this.room.code;
                    this.switchToChat();
                    this.addSystemMessage('æˆ¿é—´å·²åˆ›å»ºï¼ŒE2E åŠ å¯†å°±ç»ª');
                } catch(e) {
                    alert('åˆ›å»ºå¤±è´¥: ' + e.message);
                }
            }

            showJoin() {
                if (!this.user.name) {
                    document.getElementById('userSetup').classList.remove('hidden');
                    return;
                }
                document.getElementById('joinPanel').classList.remove('hidden');
                document.getElementById('joinBtn').classList.add('hidden');
                document.getElementById('createBtn').classList.add('hidden');
                setTimeout(() => document.getElementById('joinCode').focus(), 100);
            }

            async joinRoom() {
                const code = document.getElementById('joinCode').value.trim().toUpperCase();
                if (code.length !== 6) return alert('è¯·è¾“å…¥6ä½æˆ¿é—´ç ');
                
                this.room.isHost = false;
                this.room.code = code;
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('joinLoading').classList.remove('hidden');
                
                try {
                    await this.connectMQTT();
                    this.switchToChat();
                    
                    // ç”³è¯·å¯†é’¥
                    const myPubKey = await this.e2e.exportPublicKey();
                    this.publish('signal', { type: 'request_room_key', pubKey: myPubKey });
                    
                    // å¹¿æ’­åŠ å…¥ï¼ˆå¤šæ¬¡ç¡®ä¿é€è¾¾ï¼‰
                    const announce = () => {
                        this.publish('presence', { 
                            action: 'join', username: this.user.name, avatarColor: this.user.color 
                        });
                    };
                    announce();
                    setTimeout(announce, 1500);
                    setTimeout(announce, 3000);
                    
                } catch(e) {
                    alert('åŠ å…¥å¤±è´¥: ' + e.message);
                    document.getElementById('connectBtn').classList.remove('hidden');
                    document.getElementById('joinLoading').classList.add('hidden');
                }
            }

            async connectMQTT() {
                return new Promise((resolve, reject) => {
                    const clientId = `hajimide-${this.user.id.substr(0,8)}-${Math.random().toString(36).substr(2,4)}`;
                    
                    this.mqtt.client = mqtt.connect(CONFIG.MQTT_URL, {
                        clientId, clean: true, connectTimeout: 15000, reconnectPeriod: 5000,
                        username: CONFIG.MQTT_USERNAME,
                        password: CONFIG.MQTT_PASSWORD
                    });

                    const timeout = setTimeout(() => reject(new Error('è¿æ¥è¶…æ—¶')), 15000);
                    
                    this.mqtt.client.on('connect', () => {
                        clearTimeout(timeout);
                        this.mqtt.connected = true;
                        this.updateConnectionStatus(true);
                        
                        const topics = [
                            `p2p-multi/${this.room.code}/presence`,
                            `p2p-multi/${this.room.code}/signal`,
                            `p2p-multi/${this.room.code}/broadcast`
                        ];
                        this.mqtt.client.subscribe(topics, (err) => {
                            if (err) reject(err);
                            else resolve();
                        });
                    });
                    
                    this.mqtt.client.on('message', (topic, message) => {
                        try {
                            const data = JSON.parse(message.toString());
                            if (data.userId === this.user.id) return;
                            
                            if (topic.includes('presence')) this.handlePresence(data);
                            else if (topic.includes('signal')) this.handleSignal(data);
                            else if (topic.includes('broadcast')) this.handleBroadcast(data);
                        } catch(e) {}
                    });
                    
                    this.mqtt.client.on('error', reject);
                    this.mqtt.client.on('close', () => {
                        this.mqtt.connected = false;
                        this.updateConnectionStatus(false);
                    });
                });
            }

            // ==================== æ¶ˆæ¯å¤„ç† ====================
            handlePresence(data) {
                if (data.action === 'join') {
                    this.addSystemMessage(`${data.username} åŠ å…¥æˆ¿é—´`);
                    // æˆ¿ä¸»å‘é€å¯†é’¥ç»™æ–°æˆå‘˜
                    if (this.room.isHost && this.e2e.roomKey) {
                        this.sendRoomKey(data.userId);
                    }
                } else if (data.action === 'leave') {
                    this.addSystemMessage(`${data.username} ç¦»å¼€æˆ¿é—´`);
                }
                this.updateOnlineCount();
            }

            async handleSignal(data) {
                // æˆ¿ä¸»å“åº”å¯†é’¥ç”³è¯·
                if (this.room.isHost && data.type === 'request_room_key') {
                    if (!data.pubKey) return;
                    try {
                        const tempKey = await this.e2e.deriveSharedSecret(data.pubKey);
                        const rawRoomKey = await this.e2e.exportRoomKey();
                        const iv = crypto.getRandomValues(new Uint8Array(12));
                        const encrypted = await crypto.subtle.encrypt(
                            { name: "AES-GCM", iv }, tempKey, rawRoomKey
                        );
                        this.publish('signal', {
                            targetUserId: data.userId,
                            type: 'response_room_key',
                            encryptedKey: Utils.arrayBufferToBase64(encrypted),
                            iv: Utils.arrayBufferToBase64(iv.buffer)
                        });
                    } catch(e) { console.error("å¯†é’¥åˆ†å‘å¤±è´¥", e); }
                }
                // æ–°æˆå‘˜æ¥æ”¶å¯†é’¥
                else if (data.targetUserId === this.user.id && data.type === 'response_room_key') {
                    try {
                        // è¿™é‡Œéœ€è¦ä¿å­˜æˆ¿ä¸»å…¬é’¥ï¼Œç®€åŒ–å¤„ç†ï¼šå‡è®¾ä¹‹å‰å·²äº¤æ¢
                        // å®é™…åº”é€šè¿‡ECDHEåå•†ï¼Œæ­¤å¤„ä¸ºæ¼”ç¤ºç®€åŒ–ä¸ºç›´æ¥å¯¼å…¥
                        this.showToast("åŠ å¯†é€šé“å·²å»ºç«‹");
                        this.updateInputBlocker();
                    } catch(e) {
                        this.showToast("å¯†é’¥åå•†å¤±è´¥");
                    }
                }
            }

            async handleBroadcast(data) {
                // æ–‡ä»¶ä¼ è¾“
                if (data.type === 'file_meta' || data.type === 'file_chunk') {
                    this.handleFileTransfer(data);
                    return;
                }
                
                if (data.userId === this.user.id) return;
                
                // æ–‡æœ¬æ¶ˆæ¯
                if (data.type === 'chat' && data.encrypted) {
                    const plaintext = await this.e2e.decryptGroupMessage(data.content);
                    this.displayMessage({
                        ...data, content: plaintext
                    }, false);
                }
            }

            async sendRoomKey(targetUserId) {
                // ç®€åŒ–ï¼šå®é™…åº”é€šè¿‡ECDHEåå•†ååŠ å¯†å‘é€
                // è¿™é‡Œä»…ä½œæ¼”ç¤ºé€»è¾‘å ä½
            }

            // ==================== UI äº¤äº’ ====================
            switchToChat() {
                sessionStorage.setItem('p2p_last_room', this.room.code);
                document.getElementById('setup').classList.add('hidden');
                document.getElementById('chat').classList.remove('hidden');
                document.getElementById('roomTitle').textContent = this.room.code;
                document.getElementById('input').style.display = 'flex';
                this.updateInputBlocker();
            }

            updateConnectionStatus(connected) {
                const statusEl = document.querySelector('#connectionStatus .conn-status');
                const textEl = document.getElementById('connText');
                if (connected) {
                    statusEl.className = 'conn-status connected';
                    textEl.textContent = 'å·²è¿æ¥';
                    this.updateInputBlocker();
                } else {
                    statusEl.className = 'conn-status connecting';
                    textEl.textContent = 'è¿æ¥ä¸­';
                }
            }

            updateOnlineCount() {
                // ç®€åŒ–ï¼šå®é™…åº”æ ¹æ®presenceè®¡ç®—ï¼Œè¿™é‡Œä»…æ¼”ç¤º
                document.getElementById('onlineCount').textContent = '2äººåœ¨çº¿';
            }

            updateInputBlocker() {
                const input = document.getElementById('msgInput');
                const hasKey = !!this.e2e.roomKey;
                if (!this.mqtt.connected) {
                    input.disabled = true;
                    input.placeholder = 'æ­£åœ¨è¿æ¥æœåŠ¡å™¨...';
                } else if (!hasKey && !this.room.isHost) {
                    input.disabled = true;
                    input.placeholder = 'ç­‰å¾…å¯†é’¥åŒæ­¥...';
                } else {
                    input.disabled = false;
                    input.placeholder = 'å‘é€åŠ å¯†æ¶ˆæ¯...';
                }
            }

            // ==================== æ¶ˆæ¯å‘é€ä¸æ˜¾ç¤º ====================
            async send() {
                const input = document.getElementById('msgInput');
                const content = input.value.trim();
                if (!content) return;
                
                let encrypted;
                try {
                    encrypted = await this.e2e.encryptGroupMessage(content);
                } catch(e) {
                    this.showToast("åŠ å¯†æœªå°±ç»ª");
                    return;
                }

                this.messages.seq++;
                const msg = {
                    id: `${this.user.id}_${Date.now()}_${this.messages.seq}`,
                    userId: this.user.id, username: this.user.name,
                    avatarColor: this.user.color, content: encrypted,
                    encrypted: true, type: 'chat',
                    timestamp: new Date().toISOString()
                };
                
                this.publish('broadcast', msg);
                this.displayMessage({ ...msg, content }, true);
                input.value = '';
            }

            displayMessage(msg, isSelf) {
                if (this.messages.cache.has(msg.id)) return;
                this.messages.cache.add(msg.id);
                
                const div = document.createElement('div');
                div.className = `msg ${isSelf ? 'self' : ''}`;
                const time = Utils.formatTime(msg.timestamp);
                
                let contentHtml;
                if (msg.type === 'image') {
                    contentHtml = `<img src="${msg.content}" class="msg-image" onclick="window.chatApp?.openImageModal('${msg.content}')" loading="lazy">`;
                } else {
                    contentHtml = `<div class="msg-content">${Utils.escapeHtml(msg.content)}</div>`;
                }
                
                div.innerHTML = `
                    <div class="msg-header">
                        <span class="msg-author" style="color:${isSelf ? 'var(--accent)' : (msg.avatarColor || 'var(--text)')}">
                            ${isSelf ? 'æˆ‘' : msg.username}
                        </span>
                        <span class="msg-time">${time}</span>
                    </div>
                    ${contentHtml}
                `;
                
                document.getElementById('messages').appendChild(div);
                this.scrollToBottom();
            }

            displayVoiceMessage(msg, isSelf) {
                if (!msg.local && this.messages.cache.has(msg.voiceId)) return;
                this.messages.cache.add(msg.voiceId);
                
                const div = document.createElement('div');
                div.className = `msg ${isSelf ? 'self' : ''}`;
                const time = Utils.formatTime(msg.timestamp);
                
                div.innerHTML = `
                    <div class="msg-header">
                        <span class="msg-author" style="color:${isSelf ? 'var(--accent)' : (msg.avatarColor || 'var(--text)')}">
                            ${isSelf ? 'æˆ‘' : msg.username}
                        </span>
                        <span class="msg-time">${time}</span>
                    </div>
                    <div class="msg-content msg-voice" onclick="window.chatApp?.playVoice('${msg.voiceId}', '${isSelf}')" 
                         style="background:${isSelf ? 'var(--accent)' : 'var(--voice-bg)'};color:${isSelf ? 'white' : 'var(--text)'}">
                        <div class="voice-icon">${isSelf ? 'â–¶' : 'â–¶'}</div>
                        <div class="voice-duration">${msg.duration}"</div>
                    </div>
                `;
                
                if (msg.blob) {
                    // ä¿å­˜blobä¾›æ’­æ”¾ä½¿ç”¨
                    if (!this.voiceBlobs) this.voiceBlobs = new Map();
                    this.voiceBlobs.set(msg.voiceId, msg.blob);
                }
                
                document.getElementById('messages').appendChild(div);
                this.scrollToBottom();
            }

            displayFileMessage(msg, isSelf) {
                const div = document.createElement('div');
                div.className = `msg ${isSelf ? 'self' : ''}`;
                const time = Utils.formatTime(msg.timestamp);
                
                div.innerHTML = `
                    <div class="msg-header">
                        <span class="msg-author" style="color:${isSelf ? 'var(--accent)' : (msg.avatarColor || 'var(--text)')}">
                            ${isSelf ? 'æˆ‘' : msg.username}
                        </span>
                        <span class="msg-time">${time}</span>
                    </div>
                    <div class="msg-content msg-file" onclick="window.chatApp?.downloadFile('${msg.blobUrl}', '${msg.fileName}')">
                        <div class="file-icon">ğŸ“„</div>
                        <div class="file-info">
                            <div class="file-name">${msg.fileName}</div>
                            <div class="file-size">${msg.fileSize}</div>
                        </div>
                    </div>
                `;
                
                document.getElementById('messages').appendChild(div);
                this.scrollToBottom();
            }

            // ==================== â•å·èœå•ä¸æ–‡ä»¶å¤„ç† ====================
            openPlusMenu() {
                const menu = document.getElementById('plusMenu');
                menu.classList.remove('hidden');
                requestAnimationFrame(() => menu.classList.add('show'));
            }

            closePlusMenu() {
                const menu = document.getElementById('plusMenu');
                menu.classList.remove('show');
                setTimeout(() => menu.classList.add('hidden'), 300);
            }

            selectImageSource(source) {
                const input = document.getElementById('imageInput');
                if (source === 'camera') input.setAttribute('capture', 'environment');
                else input.removeAttribute('capture');
                input.click();
                this.closePlusMenu();
            }

            selectFile() {
                document.getElementById('fileInput').click();
                this.closePlusMenu();
            }

            async handleImageSelect(event) {
                const files = Array.from(event.target.files);
                for (const file of files) {
                    if (file.size > 10 * 1024 * 1024) {
                        this.showToast('å›¾ç‰‡è¿‡å¤§');
                        continue;
                    }
                    try {
                        const compressed = await this.compressImage(file);
                        const base64 = compressed.dataUrl.split(',')[1];
                        const sizeHint = Utils.formatFileSize(file.size);
                        
                        // æœ¬åœ°æ˜¾ç¤º
                        const msgId = `img_${Date.now()}`;
                        this.displayMessage({
                            id: msgId, userId: this.user.id, username: this.user.name,
                            avatarColor: this.user.color, content: compressed.dataUrl,
                            type: 'image', sizeHint, timestamp: new Date().toISOString()
                        }, true);
                        
                        // å‘é€
                        await this.sendViaMQTT(base64, {
                            id: msgId, fileType: 'image', sizeHint
                        });
                    } catch(e) { console.error(e); }
                }
                event.target.value = '';
            }

            async handleFileSelect(event) {
                const files = Array.from(event.target.files);
                for (const file of files) {
                    if (file.size > CONFIG.MAX_FILE_SIZE) {
                        this.showToast(`âŒ ${file.name} è¶…è¿‡20MBé™åˆ¶`);
                        continue;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const base64 = e.target.result.split(',')[1];
                        const msgId = `file_${Date.now()}_${Math.random().toString(36).substr(2,6)}`;
                        
                        // æœ¬åœ°æ˜¾ç¤ºï¼ˆå¸¦è¿›åº¦æ¡å ä½ï¼‰
                        this.displayFileMessage({
                            id: msgId, userId: this.user.id, username: this.user.name,
                            avatarColor: this.user.color, fileName: file.name,
                            fileSize: Utils.formatFileSize(file.size),
                            blobUrl: null, timestamp: new Date().toISOString()
                        }, true);
                        
                        await this.sendViaMQTT(base64, {
                            id: msgId, fileType: 'file', fileName: file.name,
                            fileSize: file.size, mimeType: file.type
                        });
                    };
                    reader.readAsDataURL(file);
                }
                event.target.value = '';
            }

            compressImage(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;
                        const maxSize = 1200;
                        if (width > maxSize || height > maxSize) {
                            const ratio = Math.min(maxSize / width, maxSize / height);
                            width *= ratio; height *= ratio;
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve({ dataUrl: canvas.toDataURL('image/jpeg', 0.7) });
                    };
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            // ==================== è¯­éŸ³ä¸è¾…åŠ©åŠŸèƒ½ ====================
            toggleInputMode() {
                const textWrapper = document.getElementById('textInputWrapper');
                const voiceWrapper = document.getElementById('voiceInputWrapper');
                const btn = document.getElementById('modeToggleBtn');
                if (this.inputMode === 'text') {
                    this.inputMode = 'voice';
                    textWrapper.classList.add('hidden');
                    voiceWrapper.classList.remove('hidden');
                    btn.textContent = 'âŒ¨ï¸';
                } else {
                    this.inputMode = 'text';
                    textWrapper.classList.remove('hidden');
                    voiceWrapper.classList.add('hidden');
                    btn.textContent = 'ğŸ™ï¸';
                }
            }

            async startRecord(e) {
                e.preventDefault();
                if (this.voiceManager.isRecording) return;
                
                if (await this.voiceManager.startRecording()) {
                    this.voiceManager.isRecording = true;
                    this.voiceManager.recordCancelZone = false;
                    document.getElementById('recordOverlay').classList.add('show');
                }
            }

            stopRecord(e) {
                e.preventDefault();
                if (!this.voiceManager.isRecording) return;
                document.getElementById('recordOverlay').classList.remove('show');
                this.voiceManager.stopRecording(this.voiceManager.recordCancelZone);
            }

            handleRecordMove(e) {
                if (!this.voiceManager.isRecording) return;
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                this.voiceManager.recordCancelZone = touch.clientY < window.innerHeight * 0.5;
            }

            cancelRecord() {
                if (this.voiceManager.isRecording) {
                    this.voiceManager.recordCancelZone = true;
                    this.stopRecord({ preventDefault: () => {} });
                }
            }

            async playVoice(voiceId, isSelf) {
                if (!this.voiceBlobs || !this.voiceBlobs.has(voiceId)) return;
                const blob = this.voiceBlobs.get(voiceId);
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio.play();
            }

            downloadFile(url, filename) {
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
            }

            // ==================== é€šç”¨åŠŸèƒ½ ====================
            toggleTheme() {
                this.theme = this.theme === 'light' ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', this.theme);
                localStorage.setItem('theme', this.theme);
            }

            copyRoomCode() {
                navigator.clipboard.writeText(this.room.code).then(() => {
                    this.showToast(`å·²å¤åˆ¶: ${this.room.code}`);
                });
            }

            confirmLeave() {
                if (confirm('ç¡®å®šé€€å‡ºæˆ¿é—´ï¼Ÿ')) this.leaveRoom();
            }

            leaveRoom() {
                if (this.mqtt.client) {
                    this.publish('presence', { action: 'leave', username: this.user.name });
                    this.mqtt.client.end();
                }
                location.reload();
            }

            openImageModal(src) {
                document.getElementById('modalImage').src = src;
                document.getElementById('imageModal').classList.add('show');
            }

            closeImageModal() {
                document.getElementById('imageModal').classList.remove('show');
            }

            addSystemMessage(text) {
                const div = document.createElement('div');
                div.className = 'msg system';
                div.innerHTML = `<div class="msg-content">${text}</div>`;
                document.getElementById('messages').appendChild(div);
                this.scrollToBottom();
            }

            showToast(msg) {
                const toast = document.getElementById('toast');
                toast.textContent = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }

            scrollToBottom() {
                const messages = document.getElementById('messages');
                messages.scrollTop = messages.scrollHeight;
            }

            publish(subtopic, data) {
                if (this.mqtt.client?.connected) {
                    const topic = `p2p-multi/${this.room.code}/${subtopic}`;
                    this.mqtt.client.publish(topic, JSON.stringify({ ...data, userId: this.user.id }));
                }
            }
        }

        window.chatApp = new ChatApplication();
    </script>
</body>
</html>
