<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å“ˆå‰ç±³å¾·çš„èŠå¤©å®¤</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        :root{
            --bg:#f5f5f7; --bg-sec:rgba(255,255,255,0.85); --surface:rgba(255,255,255,0.7);
            --text:#1d1d1f; --text-sec:#86868b; --accent:#0071e3; --accent-hover:#0077ED;
            --error:#ff3b30; --success:#34c759; --warn:#ff9f0a; --info:#5856d6;
            --border:rgba(0,0,0,0.1); --shadow:rgba(0,0,0,0.05);
            --msg-bg:#ffffff; --msg-self:#0071e3;
        }
        [data-theme="dark"]{
            --bg:#000000; --bg-sec:rgba(28,28,30,0.9); --surface:rgba(30,30,30,0.8);
            --text:#f5f5f7; --text-sec:#86868b; --accent:#0a84ff; --accent-hover:#0077ED;
            --border:rgba(255,255,255,0.15); --shadow:rgba(0,0,0,0.5);
            --msg-bg:#1c1c1e; --msg-self:#0a84ff;
        }
        
        *{margin:0;padding:0;box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text",Roboto,sans-serif;-webkit-tap-highlight-color:transparent}
        body{background:var(--bg);color:var(--text);height:100dvh;overflow:hidden;display:flex;flex-direction:column}
        .hidden{display:none!important}
        
        .glass{background:var(--bg-sec);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--border)}
        .btn{padding:12px 20px;border-radius:12px;border:none;background:var(--accent);color:white;font-weight:600;font-size:15px;cursor:pointer;transition:all .2s}
        .btn:disabled{opacity:0.5;cursor:not-allowed}
        .btn:active:not(:disabled){opacity:0.7}
        .btn.sec{background:var(--bg-sec);color:var(--text);border:1px solid var(--border)}
        .btn.danger{background:var(--error)}
        .input-box{width:100%;padding:14px;border-radius:12px;border:1px solid var(--border);background:var(--surface);color:var(--text);font-size:16px;outline:none;transition:border .2s}
        .input-box:focus{border-color:var(--accent)}
        .input-box:disabled{opacity:0.6;background:var(--bg)}

        #setup-view, #chat-view{width:100%;height:100%;position:absolute;inset:0;display:flex;flex-direction:column;transition:transform .3s ease}
        
        .setup-card{width:90%;max-width:400px;margin:auto;padding:30px;border-radius:24px;box-shadow:0 10px 40px var(--shadow);text-align:center}
        .logo{font-size:40px;margin-bottom:10px}
        .subtitle{color:var(--text-sec);font-size:13px;margin-bottom:30px;line-height:1.5}
        
        header{padding:12px 16px;display:flex;justify-content:space-between;align-items:center;z-index:10;flex-shrink:0}
        .room-tag{font-size:12px;font-weight:700;padding:4px 10px;background:var(--bg-sec);border-radius:20px;border:1px solid var(--border);display:flex;align-items:center;gap:6px;cursor:pointer}
        .status-dot{width:8px;height:8px;border-radius:50%;background:var(--text-sec);transition:background .3s}
        .status-dot.connecting{background:var(--warn);animation:pulse 1s infinite}
        .status-dot.exchange{background:var(--info);animation:pulse 1s infinite}
        .status-dot.ok{background:var(--success);box-shadow:0 0 8px var(--success)}
        .status-dot.err{background:var(--error)}
        .status-dot.reconnecting{background:var(--warn);animation:reconnect-spin 2s linear infinite;border-radius:0;clip-path:polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)}
        
        #msg-list{flex:1;overflow-y:auto;padding:20px;display:flex;flex-direction:column;gap:12px;scroll-behavior:smooth}
        .msg{max-width:80%;align-self:flex-start;animation:fadeIn .2s ease;position:relative}
        .msg.self{align-self:flex-end}
        .msg.sys{align-self:center;font-size:12px;color:var(--text-sec);background:var(--border);padding:4px 12px;border-radius:12px;max-width:90%;text-align:center}
        .bubble{padding:10px 14px;border-radius:18px;background:var(--msg-bg);border:1px solid var(--border);box-shadow:0 2px 8px var(--shadow);word-break:break-word;position:relative}
        .msg.self .bubble{background:var(--msg-self);color:white;border:none}
        .meta{font-size:10px;margin-bottom:4px;opacity:0.7;display:flex;gap:6px;align-items:center}
        
        .msg-status{font-size:12px;color:var(--text-sec);letter-spacing:-1px;font-weight:bold}
        .msg-status.read{color:#34c759}
        .msg.self .msg-status.read{color:#90ee90}
        
        .img-preview{max-width:200px;max-height:300px;border-radius:12px;display:block;cursor:pointer;object-fit:cover}
        .file-card{display:flex;align-items:center;gap:10px;padding:4px}
        .file-icon{font-size:24px}
        .progress-bar{height:3px;background:rgba(255,255,255,0.3);width:100%;margin-top:8px;border-radius:2px;overflow:hidden}
        .progress-fill{height:100%;background:white;width:0%;transition:width .2s linear}
        .msg:not(.self) .progress-bar{background:rgba(0,0,0,0.1)}
        .msg:not(.self) .progress-fill{background:var(--accent)}
        .progress-text{font-size:10px;opacity:0.8;margin-top:4px;text-align:right}

        .toolbar{padding:12px;display:flex;gap:8px;align-items:end;background:var(--bg-sec);border-top:1px solid var(--border)}
        .tool-btn{width:40px;height:40px;border-radius:50%;flex-shrink:0;display:flex;align-items:center;justify-content:center;font-size:20px;background:transparent;border:none;color:var(--text);cursor:pointer;transition:transform .1s}
        .tool-btn:active{transform:scale(0.9)}
        #chat-input{min-height:40px;max-height:100px;padding:10px 14px;resize:none;line-height:1.4;flex:1}
        #send-btn{width:auto;padding:12px 20px}
        
        #input-overlay{position:absolute;inset:0;background:transparent;z-index:5;display:none}
        #input-overlay.active{display:block}

        #diag-modal{position:fixed;inset:0;z-index:999;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center}
        .diag-box{width:90%;max-width:600px;height:80vh;display:flex;flex-direction:column;background:var(--bg);border-radius:20px;overflow:hidden;box-shadow:0 20px 50px rgba(0,0,0,0.3)}
        .diag-header{padding:16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;font-weight:bold;align-items:center}
        .diag-content{flex:1;overflow-y:auto;padding:16px;font-family:monospace;font-size:12px;background:#1e1e1e;color:#0f0;line-height:1.6}
        .diag-log-line{margin-bottom:4px;border-bottom:1px solid #333;padding-bottom:4px;word-break:break-all}
        .diag-log-line.error{color:#ff453a}
        .diag-log-line.warn{color:#ff9f0a}
        .diag-log-line.info{color:#0f0}
        .diag-log-line.debug{color:#64d2ff}
        .diag-toolbar{padding:12px;display:flex;gap:10px;background:var(--bg-sec);border-top:1px solid var(--border)}

        .key-badge{font-size:10px;padding:2px 6px;background:var(--accent);color:white;border-radius:4px;margin-left:6px;opacity:0;transition:opacity .3s}
        .key-badge.visible{opacity:1}

        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
        @keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
        @keyframes reconnect-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
        
        /* è¿æ¥çŠ¶æ€æç¤º */
        .conn-status-toast{position:fixed;top:60px;left:50%;transform:translateX(-50%);padding:8px 16px;background:var(--bg-sec);border:1px solid var(--border);border-radius:20px;font-size:13px;z-index:100;animation:slideDown 0.3s ease;display:none;backdrop-filter:blur(10px)}
        .conn-status-toast.show{display:block}
        @keyframes slideDown{from{opacity:0;transform:translate(-50%,-20px)}to{opacity:1;transform:translate(-50%,0)}}
    </style>
</head>
<body>

    <div id="conn-status" class="conn-status-toast"></div>

    <div id="diag-modal">
        <div class="diag-box">
            <div class="diag-header">
                <span>ç³»ç»Ÿè¯Šæ–­ç»ˆç«¯</span>
                <button class="btn sec" style="padding:4px 12px;font-size:12px" onclick="diag.hide()">å…³é—­</button>
            </div>
            <div id="diag-output" class="diag-content"></div>
            <div class="diag-toolbar">
                <button class="btn" onclick="diag.runFullCheck()">è¿è¡Œå…¨é¢æ£€æµ‹</button>
                <button class="btn sec" onclick="diag.copyLog()">å¤åˆ¶æ—¥å¿—</button>
                <button class="btn sec" onclick="diag.clear()">æ¸…å±</button>
            </div>
        </div>
    </div>

    <div id="setup-view" class="glass">
        <button class="tool-btn" style="position:absolute;top:20px;right:20px" onclick="diag.show()" title="ç³»ç»Ÿè¯Šæ–­">ğŸ©º</button>
        <div class="setup-card glass">
            <div class="logo">ğŸ”</div>
            <h2 style="margin-bottom:8px">å®‰å…¨åŠ å¯†ä¼šè¯</h2>
            <div class="subtitle">å“ˆå‰ç±³å¾·çš„èŠå¤©å®¤<br>å®Œå…¨åŠ å¯†ä¸ç”¨æ‹…å¿ƒä½ çš„é»‘å±DDSQ<br>ä½ æƒ³åˆå‡ºæ€æ ·çš„æ„å‘³</div>
            
            <input type="text" id="username" class="input-box" placeholder="ä½ çš„æ˜µç§°" maxlength="12" style="margin-bottom:12px;text-align:center">
            <div style="display:flex;gap:10px">
                <button class="btn" style="flex:1" onclick="app.createRoom()">æ–°å»ºæˆ¿é—´</button>
                <button class="btn sec" style="flex:1" onclick="document.getElementById('room-input-area').classList.remove('hidden')">åŠ å…¥</button>
            </div>
            
            <div id="room-input-area" class="hidden" style="margin-top:16px;animation:fadeIn .3s">
                <input type="text" id="room-code-input" class="input-box" placeholder="è¾“å…¥6ä½æˆ¿é—´ç " maxlength="6" style="text-align:center;letter-spacing:4px;text-transform:uppercase;margin-bottom:8px">
                <button class="btn" style="width:100%" onclick="app.joinRoom()">è¿›å…¥æˆ¿é—´</button>
            </div>
            
            <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border);font-size:11px;color:var(--text-sec)">
                <div>è¿æ¥åˆ°: fddd45a42e524b8795daf3247546b5ca.s1.eu.hivemq.cloud</div>
                <div style="margin-top:4px">åŠ å¯†åè®®: TLS 1.3 + WSS + MQTT v5</div>
                <div style="margin-top:4px">è¿æ¥ä¼˜åŒ–: ä¼šè¯æ¢å¤ Â· 0-RTT å¿«é€Ÿé‡è¿</div>
            </div>
        </div>
    </div>

    <div id="chat-view" class="hidden">
        <header class="glass">
            <div class="room-tag" onclick="app.copyRoomCode()" title="ç‚¹å‡»å¤åˆ¶æˆ¿é—´ç ">
                <div class="status-dot" id="conn-dot"></div>
                <span id="room-title">æ­£åœ¨æ€å¦ˆä¸­...</span>
                <span class="key-badge" id="key-badge" title="å·²å»ºç«‹ç«¯åˆ°ç«¯åŠ å¯†">E2E</span>
            </div>
            <div style="display:flex;gap:8px">
                <button class="tool-btn" onclick="app.reconnect()" title="æ‰‹åŠ¨é‡è¿">â†»</button>
                <button class="tool-btn" onclick="diag.show()" title="è¯Šæ–­">ğŸ©º</button>
                <button class="btn danger" style="padding:6px 12px;font-size:12px" onclick="app.gracefulExit()">é€€å‡º</button>
            </div>
        </header>
        
        <div id="msg-list"></div>
        
        <div class="toolbar" style="position:relative">
            <div id="input-overlay"></div>
            <button class="tool-btn" onclick="document.getElementById('file-input').click()" title="å‘é€æ–‡ä»¶">ğŸ“</button>
            <textarea id="chat-input" class="input-box" rows="1" placeholder="æ­£åœ¨å± æ€æ”¯é‚£çŒª..." disabled></textarea>
            <button id="send-btn" class="btn" onclick="app.sendText()" disabled>å‘é€</button>
        </div>
        
        <input type="file" id="file-input" class="hidden" onchange="app.sendFile(this.files[0])">
    </div>

<script>
/**
 * æ ¸å¿ƒé…ç½® - HiveMQ Cloud ç§æœ‰é›†ç¾¤ (MQTT v5)
 */
const CONFIG = {
    MQTT_URL: 'wss://fddd45a42e524b8795daf3247546b5ca.s1.eu.hivemq.cloud:8884/mqtt',
    MQTT_USER: 'hajimi',
    MQTT_PASS: '258758Szh',
};
    
    CHUNK_SIZE: 32 * 1024,
    ENCRYPT_CHUNK_SIZE: 16 * 1024,
    RETRY_DELAY: 3000,
    TIMEOUT: 300000,
    KEY_EXCHANGE_TIMEOUT: 30000,
    RECONNECT_BASE_DELAY: 2000,
    MAX_RECONNECT_ATTEMPTS: 10,
    SESSION_EXPIRY: 3600 // 1å°æ—¶ä¼šè¯è¿‡æœŸ
};

/**
 * è¯Šæ–­æ¨¡å—
 */
class Diagnostics {
    constructor() {
        this.el = document.getElementById('diag-output');
        this.modal = document.getElementById('diag-modal');
        this.logs = [];
    }
    
    show() { this.modal.style.display = 'flex'; }
    hide() { this.modal.style.display = 'none'; }
    clear() { this.el.innerHTML = ''; this.logs = []; }
    
    log(msg, type = 'info') {
        const time = new Date().toLocaleTimeString();
        const line = `[${time}] [${type.toUpperCase()}] ${msg}`;
        this.logs.push(line);
        
        const div = document.createElement('div');
        div.className = `diag-log-line ${type}`;
        div.textContent = line;
        this.el.appendChild(div);
        this.el.scrollTop = this.el.scrollHeight;
        console.log(`[${type}] ${msg}`);
    }

    copyLog() {
        navigator.clipboard.writeText(this.logs.join('\n'))
            .then(() => alert('æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'));
    }

    async runFullCheck() {
        this.log('å¼€å§‹å…¨é¢ç³»ç»Ÿæ£€æµ‹...', 'info');
        this.log(`ç›®æ ‡æœåŠ¡å™¨: ${CONFIG.MQTT_URL}`, 'info');
        this.log(`åè®®ç‰ˆæœ¬: MQTT v5 (ä¼šè¯ä¿æŒ${CONFIG.SESSION_EXPIRY}ç§’)`, 'info');
        
        this.log('æ£€æŸ¥ Web Crypto API...');
        if (!window.crypto || !window.crypto.subtle) {
            this.log('âŒ Web Crypto API ä¸å¯ç”¨', 'error');
            return;
        }
        this.log('âœ… Web Crypto API æ­£å¸¸');
        
        if (!window.TextEncoder || !window.TextDecoder) {
            this.log('âŒ Text Encoding API ä¸å¯ç”¨', 'error');
            return;
        }
        this.log('âœ… Text Encoding API æ­£å¸¸');

        try {
            const testKey = await crypto.subtle.generateKey(
                { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]
            );
            this.log('âœ… ECDH P-256 å¯†é’¥ç”Ÿæˆæ­£å¸¸');
        } catch(e) {
            this.log(`âŒ ECDH æµ‹è¯•å¤±è´¥: ${e.message}`, 'error');
        }

        this.log('æµ‹è¯• HiveMQ Cloud è¿æ¥...');
        const testClient = mqtt.connect(CONFIG.MQTT_URL, { 
            clientId: `diag_${Math.random().toString(36).substr(2, 8)}`,
            username: CONFIG.MQTT_USER,
            password: CONFIG.MQTT_PASS,
            connectTimeout: 10000,
            protocolVersion: 5
        });
        
        const start = Date.now();
        testClient.on('connect', () => {
            const latency = Date.now() - start;
            this.log(`âœ… HiveMQ Cloud è¿æ¥æˆåŠŸ (å»¶è¿Ÿ: ${latency}ms)`);
            testClient.end();
        });
        
        testClient.on('error', (err) => {
            this.log(`âŒ MQTT è¿æ¥å¤±è´¥: ${err.message}`, 'error');
            testClient.end();
        });

        if (navigator.storage?.estimate) {
            const estimate = await navigator.storage.estimate();
            const usage = (estimate.usage / 1024 / 1024).toFixed(2);
            const quota = estimate.quota ? (estimate.quota / 1024 / 1024).toFixed(0) : '?';
            this.log(`â„¹ï¸ å­˜å‚¨: ${usage}MB / ${quota}MB`);
        }
    }
}
const diag = new Diagnostics();

/**
 * åŠ å¯†æ ¸å¿ƒ
 */
class CryptoEngine {
    constructor() {
        this.keyPair = null;
        this.roomKey = null;
        this.isReady = false;
    }

    async init() {
        this.keyPair = await window.crypto.subtle.generateKey(
            { name: "ECDH", namedCurve: "P-256" },
            true,
            ["deriveKey"]
        );
        diag.log('ECDH å¯†é’¥å¯¹å·²ç”Ÿæˆ');
    }

    async exportPubKey() {
        return await window.crypto.subtle.exportKey("jwk", this.keyPair.publicKey);
    }

    async deriveSharedKey(theirPublicKeyJwk) {
        try {
            const theirPubKey = await window.crypto.subtle.importKey(
                "jwk",
                theirPublicKeyJwk,
                { name: "ECDH", namedCurve: "P-256" },
                false,
                []
            );

            this.roomKey = await window.crypto.subtle.deriveKey(
                {
                    name: "ECDH",
                    public: theirPubKey
                },
                this.keyPair.privateKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
            
            this.isReady = true;
            diag.log('å…±äº«å¯†é’¥æ´¾ç”ŸæˆåŠŸ', 'success');
            return true;
        } catch (e) {
            diag.log(`å¯†é’¥æ´¾ç”Ÿå¤±è´¥: ${e.message}`, 'error');
            throw e;
        }
    }

    async encrypt(data) {
        if (!this.roomKey) throw new Error("å¯†é’¥æœªå°±ç»ª");
        
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            this.roomKey,
            data
        );

        const result = new Uint8Array(iv.byteLength + encrypted.byteLength);
        result.set(iv, 0);
        result.set(new Uint8Array(encrypted), iv.byteLength);
        return result;
    }

    async decrypt(buffer) {
        if (!this.roomKey) throw new Error("å¯†é’¥æœªå°±ç»ª");
        if (buffer.byteLength < 13) throw new Error("å¯†æ–‡è¿‡çŸ­");
        
        const iv = buffer.slice(0, 12);
        const ciphertext = buffer.slice(12);

        try {
            const decrypted = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                this.roomKey,
                ciphertext
            );
            return decrypted;
        } catch (e) {
            throw new Error(`è§£å¯†å¤±è´¥: ${e.message}`);
        }
    }
    
    async encryptChunk(data, chunkIndex) {
        if (!this.roomKey) throw new Error("å¯†é’¥æœªå°±ç»ª");
        
        const ivBase = new Uint8Array(12);
        window.crypto.getRandomValues(ivBase);
        new DataView(ivBase.buffer).setUint32(8, chunkIndex, false);
        
        const encrypted = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: ivBase },
            this.roomKey,
            data
        );
        
        const result = new Uint8Array(12 + encrypted.byteLength);
        result.set(ivBase, 0);
        result.set(new Uint8Array(encrypted), 12);
        return result;
    }
    
    async decryptChunk(buffer) {
        return this.decrypt(buffer);
    }
    
    reset() {
        this.keyPair = null;
        this.roomKey = null;
        this.isReady = false;
    }
}

/**
 * ä¼ è¾“ç®¡ç†å™¨
 */
class TransferManager {
    constructor() {
        this.transfers = new Map();
        this.cleanupInterval = setInterval(() => this.cleanup(), 60000);
    }
    
    create(id, meta, isUpload = false) {
        this.transfers.set(id, {
            meta,
            chunks: isUpload ? null : new Uint8Array(meta.totalLen),
            receivedCount: 0,
            receivedBytes: 0,
            startTime: Date.now(),
            lastActivity: Date.now(),
            isUpload,
            uiId: `xfer-${id}`,
            chunksProgress: new Set()
        });
        return this.transfers.get(id);
    }
    
    get(id) {
        const xfer = this.transfers.get(id);
        if (xfer) xfer.lastActivity = Date.now();
        return xfer;
    }
    
    updateChunk(id, index, data) {
        const xfer = this.transfers.get(id);
        if (!xfer || xfer.isUpload) return null;
        
        if (xfer.chunksProgress.has(index)) return xfer;
        xfer.chunksProgress.add(index);
        
        const offset = index * CONFIG.CHUNK_SIZE;
        const chunk = data instanceof Uint8Array ? data : new Uint8Array(data);
        
        try {
            xfer.chunks.set(chunk, offset);
            xfer.receivedCount++;
            xfer.receivedBytes += chunk.byteLength;
        } catch (e) {
            diag.log(`å†™å…¥åˆ†ç‰‡å¤±è´¥ [${index}]: ${e.message}`, 'error');
            throw e;
        }
        
        return xfer;
    }
    
    isComplete(id) {
        const xfer = this.transfers.get(id);
        return xfer && xfer.receivedCount >= xfer.meta.totalChunks;
    }
    
    cleanup() {
        const now = Date.now();
        for (const [id, xfer] of this.transfers.entries()) {
            if (now - xfer.lastActivity > CONFIG.TIMEOUT) {
                this.transfers.delete(id);
                diag.log(`æ¸…ç†è¿‡æœŸä¼ è¾“: ${id}`, 'debug');
            }
        }
    }
    
    remove(id) {
        this.transfers.delete(id);
    }
    
    destroy() {
        clearInterval(this.cleanupInterval);
        this.transfers.clear();
    }
}

/**
 * åº”ç”¨ä¸»é€»è¾‘
 */
class App {
    constructor() {
        this.crypto = new CryptoEngine();
        this.client = null;
        this.room = null;
        this.user = { 
            id: Math.random().toString(36).substr(2, 9), 
            name: '' 
        };
        this.transfers = new TransferManager();
        this.status = 'disconnected';
        this.keyExchangeTimer = null;
        
        // æ–°å¢ï¼šå·²è¯»å›æ‰§ç³»ç»Ÿ
        this.msgStatus = new Map();
        this.pendingReceipts = new Set();
        this.flushTimer = null;
        this.observer = null;
        
        // æ–°å¢ï¼šé‡è¿æœºåˆ¶
        this.reconnectAttempts = 0;
        this.offlineQueue = [];
        this.lastDisconnectTime = null;
        this.sessionResumed = false;
        
        // æ–°å¢ï¼šè¿æ¥çŠ¶æ€æç¤º
        this.statusToast = document.getElementById('conn-status');
    }

    async init() {
        await this.crypto.init();
        
        // åˆå§‹åŒ– IntersectionObserver ç”¨äºå·²è¯»æ£€æµ‹
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                    const msgId = entry.target.dataset.msgId;
                    if (msgId && !entry.target.classList.contains('self') && 
                        this.msgStatus.get(msgId)?.status !== 'read') {
                        this.pendingReceipts.add(msgId);
                        this.flushReadReceipts();
                    }
                }
            });
        }, { threshold: 0.5 });
        
        const input = document.getElementById('chat-input');
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                this.sendText(); 
            }
        });
        
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 100) + 'px';
        });
        
        diag.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ - å·²å¯ç”¨å·²è¯»å›æ‰§ & æ™ºèƒ½é‡è¿');
    }

    setUsername() {
        const name = document.getElementById('username').value.trim();
        if (!name) {
            alert('è¯·è¾“å…¥æ˜µç§°');
            return false;
        }
        this.user.name = name;
        return true;
    }

    async createRoom() {
        if (!this.setUsername()) return;
        this.room = { 
            code: Math.random().toString(36).substr(2, 6).toUpperCase(), 
            isHost: true 
        };
        this.enterChat();
        diag.log(`åˆ›å»ºæˆ¿é—´: ${this.room.code} (Host)`);
    }

    async joinRoom() {
        if (!this.setUsername()) return;
        const code = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (code.length !== 6) {
            alert('è¯·è¾“å…¥6ä½æˆ¿é—´ç ');
            return;
        }
        this.room = { code, isHost: false };
        this.enterChat();
        diag.log(`åŠ å…¥æˆ¿é—´: ${code} (Guest)`);
    }

    enterChat() {
        document.getElementById('setup-view').classList.add('hidden');
        document.getElementById('chat-view').classList.remove('hidden');
        document.getElementById('room-title').textContent = `æˆ¿é—´: ${this.room.code}`;
        this.updateStatus('connecting');
        this.connectMQTT();
    }

    showStatusToast(text, duration = 3000) {
        this.statusToast.textContent = text;
        this.statusToast.classList.add('show');
        if (duration > 0) {
            setTimeout(() => {
                this.statusToast.classList.remove('show');
            }, duration);
        }
    }

    hideStatusToast() {
        this.statusToast.classList.remove('show');
    }

    updateStatus(newStatus, msg = '') {
        this.status = newStatus;
        const dot = document.getElementById('conn-dot');
        const badge = document.getElementById('key-badge');
        const input = document.getElementById('chat-input');
        const btn = document.getElementById('send-btn');
        
        dot.className = 'status-dot ' + newStatus;
        
        switch(newStatus) {
            case 'connecting':
                dot.title = 'æ­£åœ¨è¿æ¥ HiveMQ Cloud...';
                input.placeholder = 'æ­£åœ¨è¿æ¥æœåŠ¡å™¨...';
                input.disabled = true;
                btn.disabled = true;
                badge.classList.remove('visible');
                this.showStatusToast('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', 0);
                break;
            case 'reconnecting':
                dot.title = 'æ­£åœ¨æ™ºèƒ½é‡è¿...';
                input.placeholder = 'ç½‘ç»œæ³¢åŠ¨ï¼Œæ­£åœ¨æ¢å¤è¿æ¥...';
                input.disabled = true;
                btn.disabled = true;
                this.showStatusToast(msg || 'æ­£åœ¨é‡æ–°è¿æ¥...', 0);
                break;
            case 'exchange':
                dot.title = 'æ­£åœ¨è¿›è¡Œå¯†é’¥åå•†...';
                input.placeholder = 'æ­£åœ¨å»ºç«‹å®‰å…¨é€šé“...';
                input.disabled = true;
                btn.disabled = true;
                badge.classList.remove('visible');
                this.hideStatusToast();
                break;
            case 'ready':
                dot.title = 'å·²å»ºç«‹ç«¯åˆ°ç«¯åŠ å¯†è¿æ¥';
                input.placeholder = 'å‘é€åŠ å¯†æ¶ˆæ¯...';
                input.disabled = false;
                btn.disabled = false;
                badge.classList.add('visible');
                this.hideStatusToast();
                if (!this.sessionResumed) {
                    this.appendSysMsg('ğŸ”’ ç«¯åˆ°ç«¯åŠ å¯†é€šé“å·²å»ºç«‹ï¼Œå¯ä»¥å¼€å§‹å®‰å…¨é€šè®¯');
                }
                break;
            case 'err':
                dot.title = 'è¿æ¥é”™è¯¯';
                input.placeholder = 'è¿æ¥å¤±è´¥ï¼Œç‚¹å‡»â†»æ‰‹åŠ¨é‡è¿';
                input.disabled = true;
                btn.disabled = true;
                badge.classList.remove('visible');
                this.showStatusToast('è¿æ¥å¤±è´¥', 3000);
                break;
        }
    }

    async connectMQTT() {
        if (this.client?.connected) return;
        
        const clientId = `e2e_${this.user.id}_${Date.now().toString(36)}`;
        
        try {
            // MQTT v5 é…ç½®ä¼˜åŒ–
            this.client = mqtt.connect(CONFIG.MQTT_URL, { 
                clientId,
                username: CONFIG.MQTT_USER,
                password: CONFIG.MQTT_PASS,
                clean: false, // å…³é”®ï¼šå¯ç”¨ä¼šè¯æ¢å¤
                keepalive: 60,
                connectTimeout: 15000,
                reconnectPeriod: 0, // ç¦ç”¨è‡ªåŠ¨é‡è¿ï¼Œä½¿ç”¨è‡ªå®šä¹‰é€»è¾‘
                protocolVersion: 5,
                properties: {
                    sessionExpiryInterval: CONFIG.SESSION_EXPIRY
                }
            });

            this.setupEventHandlers();
            
        } catch (e) {
            diag.log(`è¿æ¥åˆå§‹åŒ–å¤±è´¥: ${e.message}`, 'error');
            this.scheduleReconnect();
        }
    }

    setupEventHandlers() {
        this.client.on('connect', (connack) => {
            this.onConnect(connack);
        });

        this.client.on('reconnect', () => {
            diag.log('æ­£åœ¨é‡è¿ HiveMQ Cloud...', 'warn');
            this.updateStatus('reconnecting');
        });

        this.client.on('close', () => {
            this.onDisconnect();
        });

        this.client.on('offline', () => {
            diag.log('HiveMQ Cloud è¿æ¥ç¦»çº¿', 'warn');
        });

        this.client.on('error', (err) => {
            diag.log(`è¿æ¥é”™è¯¯: ${err.message}`, 'error');
            this.updateStatus('err');
        });

        this.client.on('message', (topic, payload) => {
            this.handleMessage(topic, payload).catch(e => {
                diag.log(`æ¶ˆæ¯å¤„ç†é”™è¯¯: ${e.message}`, 'error');
            });
        });
    }

    async onConnect(connack) {
        diag.log('HiveMQ Cloud å·²è¿æ¥');
        this.reconnectAttempts = 0;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºä¼šè¯æ¢å¤
        if (connack.sessionPresent && this.crypto.isReady && this.room) {
            diag.log('æ£€æµ‹åˆ°ç°æœ‰ä¼šè¯ï¼Œæ‰§è¡Œå¿«é€Ÿæ¢å¤...');
            this.sessionResumed = true;
            this.resubscribeTopics();
            this.updateStatus('ready');
            this.showStatusToast('âš¡ å·²å¿«é€Ÿæ¢å¤åŠ å¯†ä¼šè¯', 2000);
            this.flushOfflineQueue();
            return;
        }
        
        this.sessionResumed = false;
        
        const topics = [
            `secure-chat/${this.room.code}/ctrl`,
            `secure-chat/${this.room.code}/bin/+`
        ];
        
        this.client.subscribe(topics, { qos: 1 }, (err) => {
            if (err) {
                diag.log('è®¢é˜…å¤±è´¥: ' + err.message, 'error');
                return;
            }
            this.beginKeyExchange();
        });
    }

    onDisconnect() {
        if (this.status === 'disconnected') return;
        
        this.lastDisconnectTime = Date.now();
        diag.log('è¿æ¥æ–­å¼€ï¼Œå¯åŠ¨é‡è¿æœºåˆ¶...', 'warn');
        
        // å¦‚æœå¯†é’¥è¿˜åœ¨ï¼Œå°è¯•å¿«é€Ÿæ¢å¤
        if (this.crypto.isReady && this.status === 'ready') {
            this.updateStatus('reconnecting', 'åŠ å¯†é€šé“ä¸­æ–­ï¼Œæ­£åœ¨æ¢å¤...');
            this.scheduleReconnect(true); // å¿«é€Ÿé‡è¿
        } else {
            this.updateStatus('reconnecting', 'è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...');
            this.scheduleReconnect(false);
        }
    }

    scheduleReconnect(fast = false) {
        if (this.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
            this.updateStatus('err');
            this.appendSysMsg('âš ï¸ æ— æ³•æ¢å¤è¿æ¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåç‚¹å‡» â†» æ‰‹åŠ¨åˆ·æ–°');
            return;
        }
        
        this.reconnectAttempts++;
        
        let delay;
        if (fast) {
            delay = 1000; // å¿«é€Ÿé‡è¿1ç§’
        } else {
            delay = Math.min(
                CONFIG.RECONNECT_BASE_DELAY * Math.pow(1.5, this.reconnectAttempts - 1), 
                30000
            );
        }
        
        diag.log(`è®¡åˆ’ ${delay/1000}ç§’åç¬¬ ${this.reconnectAttempts} æ¬¡é‡è¿...`, 'warn');
        
        setTimeout(() => {
            if (!this.client.connected) {
                this.client.reconnect();
            }
        }, delay);
    }

    async reconnect() {
        diag.log('æ‰§è¡Œæ‰‹åŠ¨é‡è¿...');
        this.reconnectAttempts = 0;
        if (this.client) {
            this.client.reconnect();
        } else {
            this.connectMQTT();
        }
    }

    resubscribeTopics() {
        if (!this.client?.connected) return;
        const topics = [
            `secure-chat/${this.room.code}/ctrl`,
            `secure-chat/${this.room.code}/bin/+`
        ];
        this.client.subscribe(topics, { qos: 1 }, (err) => {
            if (!err) diag.log('ä¸»é¢˜é‡æ–°è®¢é˜…æˆåŠŸ');
        });
    }

    async beginKeyExchange() {
        this.updateStatus('exchange');
        
        if (this.room.isHost) {
            diag.log('Host: ç­‰å¾… Guest å…¬é’¥...');
            this.keyExchangeTimer = setTimeout(() => {
                if (this.status !== 'ready') {
                    this.updateStatus('err');
                    this.appendSysMsg('âš ï¸ å¯†é’¥åå•†è¶…æ—¶ï¼šæœªæ”¶åˆ° Guest å“åº”');
                }
            }, CONFIG.KEY_EXCHANGE_TIMEOUT);
        } else {
            try {
                const pubKey = await this.crypto.exportPubKey();
                this.publishCtrl('pubkey', { pubKey });
                diag.log('Guest: å·²å‘é€å…¬é’¥ï¼Œç­‰å¾… Host å“åº”...');
                
                this.keyExchangeTimer = setTimeout(() => {
                    if (this.status !== 'ready') {
                        this.updateStatus('err');
                        this.appendSysMsg('âš ï¸ å¯†é’¥åå•†è¶…æ—¶ï¼šæœªæ”¶åˆ° Host å“åº”');
                    }
                }, CONFIG.KEY_EXCHANGE_TIMEOUT);
            } catch (e) {
                diag.log(`å‘é€å…¬é’¥å¤±è´¥: ${e.message}`, 'error');
            }
        }
    }

    publishCtrl(type, payload) {
        if (!this.client?.connected) {
            // æ–­çº¿æœŸé—´æ¶ˆæ¯å…¥é˜Ÿï¼ˆä»…èŠå¤©æ¶ˆæ¯ï¼‰
            if (type === 'chat') {
                this.offlineQueue.push({ type, payload, time: Date.now() });
                this.appendSysMsg('â³ æ¶ˆæ¯å°†åœ¨è¿æ¥æ¢å¤åå‘é€');
            }
            return;
        }
        
        const msg = {
            senderId: this.user.id,
            senderName: this.user.name,
            type,
            payload,
            ts: Date.now()
        };
        this.client.publish(
            `secure-chat/${this.room.code}/ctrl`, 
            JSON.stringify(msg),
            { qos: 1 }
        );
    }

    flushOfflineQueue() {
        if (this.offlineQueue.length === 0) return;
        diag.log(`æ¢å¤å‘é€ ${this.offlineQueue.length} æ¡ç¦»çº¿æ¶ˆæ¯...`);
        
        const validMessages = this.offlineQueue.filter(msg => 
            Date.now() - msg.time < 300000 // åªå‘é€5åˆ†é’Ÿå†…çš„
        );
        
        validMessages.forEach(msg => {
            this.publishCtrl(msg.type, msg.payload);
        });
        
        this.offlineQueue = [];
        if (validMessages.length > 0) {
            this.appendSysMsg(`ğŸ“¤ ${validMessages.length} æ¡ç¦»çº¿æ¶ˆæ¯å·²åŒæ­¥`);
        }
    }

    async handleMessage(topic, payload) {
        if (topic.includes('/bin/')) {
            const parts = topic.split('/');
            const transferId = parts[parts.length - 2];
            const chunkIndex = parseInt(parts[parts.length - 1]);
            await this.handleBinaryChunk(transferId, chunkIndex, payload);
            return;
        }

        let msg;
        try {
            msg = JSON.parse(payload.toString());
        } catch (e) {
            diag.log('æ— æ•ˆçš„ JSON æ¶ˆæ¯', 'error');
            return;
        }

        if (msg.senderId === this.user.id) return;

        // å¯†é’¥åå•†æ¶ˆæ¯
        if (msg.type === 'pubkey' || msg.type === 'pubkey_response') {
            await this.processKeyMessage(msg);
            return;
        }

        if (this.status !== 'ready' && !this.crypto.isReady) {
            diag.log(`æ”¶åˆ° ${msg.type} ä½†é€šé“æœªå°±ç»ª`, 'warn');
            return;
        }

        switch (msg.type) {
            case 'chat':
                await this.handleChatMessage(msg);
                break;
            case 'file_meta':
                this.handleFileMeta(msg);
                break;
            case 'delivered':
                this.handleDelivered(msg);
                break;
            case 'read_receipt':
                this.handleReadReceipt(msg);
                break;
            default:
                diag.log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${msg.type}`, 'warn');
        }
    }

    async processKeyMessage(msg) {
        if (msg.type === 'pubkey' && this.room.isHost) {
            try {
                await this.crypto.deriveSharedKey(msg.payload.pubKey);
                diag.log('Host: å·²æ´¾ç”Ÿå…±äº«å¯†é’¥');
                
                const myPubKey = await this.crypto.exportPubKey();
                this.publishCtrl('pubkey_response', { pubKey: myPubKey });
                
                this.updateStatus('ready');
                if (this.keyExchangeTimer) clearTimeout(this.keyExchangeTimer);
            } catch (e) {
                diag.log(`Host å¯†é’¥æ´¾ç”Ÿå¤±è´¥: ${e.message}`, 'error');
            }
        } else if (msg.type === 'pubkey_response' && !this.room.isHost) {
            try {
                await this.crypto.deriveSharedKey(msg.payload.pubKey);
                diag.log('Guest: å·²æ´¾ç”Ÿå…±äº«å¯†é’¥');
                this.updateStatus('ready');
                if (this.keyExchangeTimer) clearTimeout(this.keyExchangeTimer);
            } catch (e) {
                diag.log(`Guest å¯†é’¥æ´¾ç”Ÿå¤±è´¥: ${e.message}`, 'error');
            }
        }
    }

    async handleChatMessage(msg) {
        try {
            const encryptedData = new Uint8Array(msg.payload.data);
            const decrypted = await this.crypto.decrypt(encryptedData);
            const text = new TextDecoder().decode(decrypted);
            
            const msgId = msg.payload.msgId || `legacy_${Date.now()}`;
            this.appendMsg(msg.senderName, text, false, msgId, 'delivered');
            
            // å‘é€é€è¾¾å›æ‰§
            this.publishCtrl('delivered', { msgId: msgId });
            
        } catch (e) {
            diag.log(`è§£å¯†æ¶ˆæ¯å¤±è´¥: ${e.message}`, 'error');
            this.appendSysMsg(`âš ï¸ æ— æ³•è§£å¯†æ¥è‡ª ${msg.senderName} çš„æ¶ˆæ¯`);
        }
    }

    handleDelivered(msg) {
        const { msgId } = msg.payload;
        if (msgId) this.updateMsgStatus(msgId, 'delivered');
    }

    handleReadReceipt(msg) {
        const { msgIds, senderName } = msg.payload;
        if (msgIds && Array.isArray(msgIds)) {
            msgIds.forEach(id => this.updateMsgStatus(id, 'read'));
            diag.log(`${senderName} å·²è¯» ${msgIds.length} æ¡æ¶ˆæ¯`, 'debug');
        }
    }

    handleFileMeta(msg) {
        const meta = msg.payload;
        diag.log(`å‡†å¤‡æ¥æ”¶æ–‡ä»¶: ${meta.name} (${meta.totalChunks} ç‰‡)`);
        
        const xfer = this.transfers.create(meta.id, meta, false);
        this.appendFileMsg(msg.senderName, meta.name, meta.size, xfer.uiId, false);
        
        setTimeout(() => {
            if (!this.transfers.isComplete(meta.id)) {
                this.transfers.remove(meta.id);
                const el = document.getElementById(xfer.uiId);
                if (el) {
                    el.querySelector('.bubble').innerHTML += '<div style="color:var(--error);font-size:12px;margin-top:4px">æ¥æ”¶è¶…æ—¶</div>';
                }
            }
        }, CONFIG.TIMEOUT);
    }

    async handleBinaryChunk(id, index, payload) {
        const xfer = this.transfers.get(id);
        if (!xfer) {
            diag.log(`æ”¶åˆ°æœªçŸ¥ä¼ è¾“çš„åˆ†ç‰‡ [${id}]`, 'warn');
            return;
        }

        try {
            const encryptedChunk = new Uint8Array(payload);
            const decryptedChunk = await this.crypto.decryptChunk(encryptedChunk);
            
            this.transfers.updateChunk(id, index, new Uint8Array(decryptedChunk));
            
            const progress = (xfer.receivedCount / xfer.meta.totalChunks) * 100;
            this.updateFileProgress(xfer.uiId, progress);
            
            if (this.transfers.isComplete(id)) {
                diag.log(`æ–‡ä»¶ [${id}] æ¥æ”¶å®Œæˆï¼Œç»„è£…ä¸­...`);
                await this.finalizeFile(id);
            }
        } catch (e) {
            diag.log(`å¤„ç†åˆ†ç‰‡å¤±è´¥ [${index}]: ${e.message}`, 'error');
        }
    }

    async finalizeFile(id) {
        const xfer = this.transfers.get(id);
        if (!xfer) return;
        
        try {
            const blob = new Blob([xfer.chunks], { type: xfer.meta.mime });
            const url = URL.createObjectURL(blob);
            this.updateFileUI(xfer.uiId, url, xfer.meta.mime, xfer.meta.name);
            this.transfers.remove(id);
            diag.log(`æ–‡ä»¶ ${xfer.meta.name} å¤„ç†å®Œæˆ`);
        } catch (e) {
            diag.log(`ç»„è£…æ–‡ä»¶å¤±è´¥: ${e.message}`, 'error');
        }
    }

    // å·²è¯»å›æ‰§é˜²æŠ–å‘é€
    flushReadReceipts() {
        if (this.flushTimer) return;
        this.flushTimer = setTimeout(() => {
            if (this.pendingReceipts.size > 0 && this.status === 'ready') {
                const receipts = Array.from(this.pendingReceipts);
                this.publishCtrl('read_receipt', { msgIds: receipts });
                this.pendingReceipts.clear();
            }
            this.flushTimer = null;
        }, 500);
    }

    updateMsgStatus(msgId, status) {
        const record = this.msgStatus.get(msgId);
        if (!record || record.status === status) return;
        
        record.status = status;
        const statusEl = record.el.querySelector('.msg-status');
        if (!statusEl) return;
        
        const icons = {
            'sent': 'âœ“',
            'delivered': 'âœ“âœ“', 
            'read': 'âœ“âœ“'
        };
        statusEl.textContent = icons[status] || '';
        statusEl.className = `msg-status ${status === 'read' ? 'read' : ''}`;
    }

    async sendText() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if (!text || this.status !== 'ready') return;
        
        const msgId = `${this.user.id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
        
        try {
            const encoded = new TextEncoder().encode(text);
            const encrypted = await this.crypto.encrypt(encoded);
            
            this.publishCtrl('chat', { 
                msgId,
                data: Array.from(encrypted),
                len: encrypted.length 
            });
            
            // æœ¬åœ°è®°å½•ä¸ºå·²å‘é€
            this.appendMsg('æˆ‘', text, true, msgId, 'sent');
            input.value = '';
            input.style.height = 'auto';
        } catch (e) {
            diag.log(`å‘é€å¤±è´¥: ${e.message}`, 'error');
            alert('å‘é€å¤±è´¥: ' + e.message);
        }
    }

    async sendFile(file) {
        if (!file || this.status !== 'ready') return;
        
        const transferId = Math.random().toString(36).substr(2, 9);
        const uiId = `xfer-${transferId}`;
        
        diag.log(`å¼€å§‹å‘é€æ–‡ä»¶: ${file.name} (${(file.size/1024/1024).toFixed(2)}MB)`);
        
        this.appendFileMsg('æˆ‘', file.name, file.size, uiId, true);
        const progressEl = document.querySelector(`#${uiId} .progress-fill`);
        
        try {
            const buffer = await file.arrayBuffer();
            const chunks = [];
            const totalChunks = Math.ceil(buffer.byteLength / CONFIG.ENCRYPT_CHUNK_SIZE);
            
            // åŠ å¯†é˜¶æ®µ
            for (let i = 0; i < totalChunks; i++) {
                const start = i * CONFIG.ENCRYPT_CHUNK_SIZE;
                const end = Math.min(start + CONFIG.ENCRYPT_CHUNK_SIZE, buffer.byteLength);
                const chunkData = buffer.slice(start, end);
                
                const encrypted = await this.crypto.encryptChunk(new Uint8Array(chunkData), i);
                chunks.push(encrypted);
                
                const progress = ((i + 1) / totalChunks) * 50;
                if (progressEl) progressEl.style.width = `${progress}%`;
            }
            
            // å‘é€ Meta
            this.publishCtrl('file_meta', {
                id: transferId,
                name: file.name,
                size: file.size,
                mime: file.type || 'application/octet-stream',
                totalChunks: chunks.length,
                totalLen: buffer.byteLength
            });
            
            // å‘é€äºŒè¿›åˆ¶
            const baseTopic = `secure-chat/${this.room.code}/bin/${transferId}`;
            
            for (let i = 0; i < chunks.length; i++) {
                await new Promise((resolve, reject) => {
                    this.client.publish(`${baseTopic}/${i}`, chunks[i], { qos: 1 }, (err) => {
                        if (err) reject(err);
                        else resolve();
                    });
                });
                
                const progress = 50 + ((i + 1) / chunks.length) * 50;
                if (progressEl) progressEl.style.width = `${progress}%`;
                
                if (i % 10 === 0) await new Promise(r => setTimeout(r, 10));
            }
            
            diag.log(`æ–‡ä»¶å‘é€å®Œæˆ: ${transferId}`);
            if (progressEl) progressEl.style.width = '100%';
            
        } catch (e) {
            diag.log(`å‘é€æ–‡ä»¶å¤±è´¥: ${e.message}`, 'error');
            alert('å‘é€æ–‡ä»¶å¤±è´¥: ' + e.message);
        }
        
        document.getElementById('file-input').value = '';
    }

    appendMsg(name, text, isSelf, msgId = null, initialStatus = null) {
        const div = document.createElement('div');
        div.className = `msg ${isSelf ? 'self' : ''}`;
        if (msgId) {
            div.dataset.msgId = msgId;
            this.msgStatus.set(msgId, { el: div, status: initialStatus, time: Date.now() });
        }
        
        const statusHtml = isSelf && msgId ? 
            `<span class="msg-status">${initialStatus === 'sent' ? 'âœ“' : 'âœ“âœ“'}</span>` : '';
        
        div.innerHTML = `
            <div class="meta">${this.escapeHtml(name)} â€¢ ${new Date().toLocaleTimeString()} ${statusHtml}</div>
            <div class="bubble">${this.escapeHtml(text)}</div>
        `;
        
        this.renderMsg(div);
        
        // å¦‚æœæ˜¯å¯¹æ–¹æ¶ˆæ¯ï¼Œè§‚å¯Ÿå¯è§æ€§
        if (!isSelf && this.observer && msgId) {
            this.observer.observe(div);
        }
        
        return div;
    }
    
    appendSysMsg(text) {
        const div = document.createElement('div');
        div.className = 'msg sys';
        div.textContent = text;
        this.renderMsg(div);
    }

    appendFileMsg(name, fileName, size, uiId, isSelf) {
        const div = document.createElement('div');
        div.className = `msg ${isSelf ? 'self' : ''}`;
        if (uiId) div.id = uiId;
        
        const sizeStr = size > 1024*1024 ? 
            (size/1024/1024).toFixed(2) + ' MB' : 
            (size/1024).toFixed(1) + ' KB';
        
        div.innerHTML = `
            <div class="meta">${this.escapeHtml(name)} â€¢ ${new Date().toLocaleTimeString()}</div>
            <div class="bubble">
                <div class="file-card">
                    <div class="file-icon">ğŸ“„</div>
                    <div style="flex:1;min-width:0">
                        <div style="font-weight:bold;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${this.escapeHtml(fileName)}</div>
                        <div style="font-size:11px;opacity:0.8">${sizeStr}</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${isSelf ? '0%' : '0%'}"></div>
                </div>
            </div>
        `;
        this.renderMsg(div);
    }

    updateFileProgress(uiId, percent) {
        const el = document.querySelector(`#${uiId} .progress-fill`);
        if (el) el.style.width = `${percent}%`;
    }

    updateFileUI(uiId, url, mime, fileName) {
        const div = document.getElementById(uiId);
        if (!div) return;
        const bubble = div.querySelector('.bubble');
        
        if (mime.startsWith('image/')) {
            bubble.innerHTML = `
                <div class="meta">${div.querySelector('.meta').innerHTML}</div>
                <img src="${url}" class="img-preview" onclick="window.open('${url}')" title="ç‚¹å‡»æŸ¥çœ‹å¤§å›¾">
            `;
        } else {
            bubble.innerHTML = `
                <div class="meta">${div.querySelector('.meta').innerHTML}</div>
                <div class="file-card">
                    <div class="file-icon">ğŸ“</div>
                    <div style="flex:1;min-width:0">
                        <div style="font-weight:bold;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${this.escapeHtml(fileName)}</div>
                        <a href="${url}" download="${fileName}" class="btn sec" style="display:inline-block;margin-top:6px;padding:4px 12px;font-size:12px;text-decoration:none">ä¸‹è½½</a>
                    </div>
                </div>
            `;
        }
    }

    renderMsg(el) {
        const list = document.getElementById('msg-list');
        list.appendChild(el);
        list.scrollTop = list.scrollHeight;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    copyRoomCode() {
        if (this.room?.code) {
            navigator.clipboard.writeText(this.room.code)
                .then(() => alert('æˆ¿é—´ç å·²å¤åˆ¶: ' + this.room.code));
        }
    }

    gracefulExit() {
        if (confirm('ç¡®å®šé€€å‡ºæˆ¿é—´ï¼Ÿ')) {
            this.status = 'disconnected';
            if (this.client) {
                this.client.end(true);
            }
            this.transfers.destroy();
            if (this.observer) this.observer.disconnect();
            location.reload();
        }
    }
}

// å¯åŠ¨
const app = new App();
app.init();
</script>
</body>

</html>

