const CONFIG = {
    MAX_RETRIES: 3,
    TIMEOUT: 20000,  // 国内网络延迟高，延长超时
    
    // Nostr 中继（保持不变）
    RELAYS: [
        'wss://relay.damus.io',
        'wss://nos.lol',
        'wss://relay.nostr.band'
    ],
    
    // STUN 服务器：增加数量提高直连成功率（方案三）
    STUN: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun.cloudflare.com:3478' },
        { urls: 'stun:stun.miwifi.com' }  // 国内小米 STUN，延迟低
    ],
    
    // TURN 服务器：Metered 国内优化（方案二）
    // 优先级：TCP 443 > TCP 80 > UDP
    TURN_SERVERS: [
        {
            // 主：TCP 443（伪装 HTTPS，穿透企业防火墙）
            urls: 'turn:standard.relay.metered.ca:443?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
        },
        {
            // 备：TCP 80（极严格防火墙环境）
            urls: 'turn:standard.relay.metered.ca:80?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
        },
        {
            // 应急：UDP（低延迟，如果网络允许）
            urls: 'turn:standard.relay.metered.ca:80?transport=udp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
        }
    ]
};

// 修改 Network.connect 中的配置
class Network {
    static async connect(roomId, key, onMsg, onPeer) {
        const { joinRoom } = await import('https://cdn.jsdelivr.net/npm/trystero@0.20.0/+esm ');
        
        // 国内网络优化配置
        const rtcConfig = {
            // ICE 服务器顺序：STUN 优先（尝试直连）→ TURN（中继兜底）
            iceServers: [
                ...CONFIG.STUN,           // 先尝试 P2P 直连（方案三）
                ...CONFIG.TURN_SERVERS    // 失败时 fallback 到 TURN（方案二）
            ],
            
            // 关键：允许所有传输方式，优先尝试直连，失败自动切换 TURN
            iceTransportPolicy: 'all',
            
            // 预收集候选，加快连接建立（国内网络慢，需要提前收集）
            iceCandidatePoolSize: 10,
            
            // 多路复用，减少端口消耗（国内防火墙对多端口敏感）
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            
            // 增加 ICE 检查超时（国内 NAT 响应慢）
            iceCandidateCheckTimeout: 5000,
            
            // 强制使用中继候选的阈值（如果设置，0表示自动）
            // iceCandidatePoolSize 配合这个可以优化
        };

        const room = joinRoom({
            appId: 'srl-'+roomId.slice(0,8),
            relayUrls: CONFIG.RELAYS,
            password: roomId,
            maxPeers: 6,
            rtcConfig: rtcConfig
        }, roomId);

        const [send, recv] = room.makeAction('m');
        recv((data, pid) => onMsg(data, pid));
        room.onPeerJoin(pid => onPeer(pid, true));
        room.onPeerLeave(pid => onPeer(pid, false));
        
        // 新增：监控 ICE 连接状态，便于诊断
        this.monitorICE(room, pid => onPeer(pid, false));
        
        return { room, send };
    }
    
    // 新增：ICE 状态监控（调试用，可看到是否走了 TURN）
    static monitorICE(room, onDisconnect) {
        // Trystero 0.20.0 暴露的 pc 访问方式可能不同，这里做兼容处理
        setTimeout(() => {
            const pcs = room._pcs || room.pcs || [];
            pcs.forEach((pc, peerId) => {
                if (!pc) return;
                
                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    Diag.log(`ICE 状态: ${state}`, 
                        state === 'connected' ? 'ok' : 
                        state === 'failed' ? 'e' : 'i');
                    
                    // 检测是否使用了 TURN（中继）还是直连
                    pc.getStats().then(stats => {
                        stats.forEach(report => {
                            if (report.type === 'candidate-pair' && report.nominated) {
                                const local = stats.get(report.localCandidateId);
                                const remote = stats.get(report.remoteCandidateId);
                                if (local && remote) {
                                    const isRelay = local.candidateType === 'relay' || 
                                                  remote.candidateType === 'relay';
                                    Diag.log(isRelay ? '通过 TURN 中继连接' : 'P2P 直连成功', 
                                           isRelay ? 'w' : 'ok');
                                }
                            }
                        });
                    });
                };
            });
        }, 1000);
    }
}
